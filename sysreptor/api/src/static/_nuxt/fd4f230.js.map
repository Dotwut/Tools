{"version":3,"sources":["webpack:///../packages/markdown/mdext/helpers.js","webpack:///../packages/markdown/mdext/footnotes.js","webpack:///../packages/markdown/mdext/gfm.js","webpack:///../packages/markdown/mdext/rehypePlugins.js","webpack:///../packages/markdown/mdext/attrs.js","webpack:///../packages/markdown/mdext/image.js","webpack:///../packages/markdown/mdext/tables.js","webpack:///../packages/markdown/editor/annotatedtext.js","webpack:///../packages/markdown/mdext/templates.js","webpack:///../packages/markdown/mdext/todo.js","webpack:///../packages/markdown/mdext/codeHighlight.js","webpack:///../packages/markdown/index.js","webpack:///../packages/markdown/editor/micromark-utils.js"],"names":["addRemarkExtension","self","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","data","add","field","value","push","assert","bool","msg","Error","remarkFootnotes","this","_hiddenFootnoteSupport","text","codes","caret","tokenize","effects","ok","nok","code","enter","consume","exit","inlineFootnoteStart","leftSquareBracket","resolveAll","resolveAllFootnote","rightSquareBracket","hasStart","index","events","length","type","resolveTo","context","token","openIndex","undefined","group","start","Object","assign","end","note","splice","parser","constructs","insideSpan","null","slice","footnoteSyntax","inlineFootnote","children","unsafe","character","inConstruct","handlers","footnote","node","_","subexit","containerPhrasing","before","after","remarkToRehypeHandlersFootnotes","h","all","footnoteDefinition","footnoteReference","rehypeFootnoteSeparator","tree","visit","parent","tagName","class","rehypeFootnoteSeparatorPreview","properties","dataFootnoteRef","nextSibling","remarkStrikethrough","gfmStrikethrough","gfmStrikethroughFromMarkdown","gfmStrikethroughToMarkdown","remarkTaskListItem","gfmTaskListItem","gfmTaskListItemFromMarkdown","gfmTaskListItemToMarkdown","rehypeLinkTargetBlank","href","startsWith","target","rel","rehypeConvertAttrsToStyle","convertAttrs","entries","attrName","styleName","style","addClass","className","Array","isArray","rehypeRewriteImageSources","rewriteImageSource","src","rehypeRewriteFileLinks","rewriteFileUrl","download","rehypeTemplates","content","attrsFromMarkdown","transforms","prevNode","hProperties","attrs","attrsString","textAttributes","setData","buffer","cleaned","getData","attribute","resume","stack","sliceSerialize","textAttributeClassValue","parseEntities","textAttributeIdValue","textAttributeName","textAttributeValue","list","remarkToRehypeAttrs","attributes","remarkAttrs","name","leftCurlyBrace","factoryAttributes","map","k","v","split","c","join","remarkFigure","image","title","url","alt","label","fragment","peek","safeOptions","quote","checkQuote","suffix","tracker","track","move","current","test","safe","figureToMarkdown","remarkToRehypeHandlersFigure","normalizeUri","remarkTables","gfmTable","gfmTableFromMarkdown","gfmTableToMarkdown","remarkTableCaptions","captionBlock","captionText","captionPrefixLength","captionVal","captionValTrimmed","trimStart","position","column","offset","tableCaption","remarkToRehypeHandlersTableCaptions","rehypeTableCaptions","tableNode1","tableNode2","createBlockSeparator","pos","micromarkToAnnotatedText","micromarkEventsToTree","i","leafNodes","interpretAsLeafNodes","interpretAsLeafNodesFns","wrapTypesWithBlockSeparators","collectLeafNodes","t","n","wrapWithSeparators","includes","extractLeafNodesFromMicromarkTree","textTypes","markupTypesInterpretAs","annotatedText","markup","interpretAs","annotatedTextParse","Parser","parseMicromarkEvents","extensions","remarkTemplateVariables","closeBraceCount","start2","between","eof","rightCurlyBrace","sequenceClose","templateVariable","remarkTodoMarker","uppercaseT","tokenizeTodo","lowercaseT","middleO","uppercaseO","lowercaseO","middleDorDash","dash","middleD","uppercaseD","lowercaseD","endO","todoSyntax","todo","hName","splitTreeAtPosition","splitPos","processChildren","flat","currentPos","childrenLeft","childrenRight","processNode","pc","toString","nodeLength","wrapTreeAreas","wrapInfos","wi","startMarkerPos","endMarkerPos","ci","wii","concat","markerTree","rehypeHighlightCode","meta","metaLine","fromEntries","from","matchAll","m","camelCase","groups","highlightManual","lineNumbers","Number","parseInt","parseMeta","highlightInfos","highlightMarkerRe","highlightedAreaRe","RegExp","parts","codeNew","highlightInfo","startMarker","endMarker","parseManualHighlightAreas","language","filter","toLowerCase","getLanguage","lowlight","highlight","error","highlightSyntax","hi","unified","use","rehypeParse","parse","applyManualHighlighting","lines","line","dataLineNumber","splitIntoLines","rehypeSanitizeSchema","merge","defaultSchema","allowComments","clobberPrefix","tagNames","markdownParser","renderMarkdownToHtml","preview","rewriteFileSource","md","remarkParse","remarkRehype","allowDangerousHtml","footnoteLabelTagName","rehypeRaw","rehypeSanitize","rehypeStringify","mdHtml","processSync","markdownToAnnotatedText","config","postprocess","document","write","preprocess","action","treeNode"],"mappings":"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","file":"fd4f230.js","sourcesContent":["export function addRemarkExtension(self, micromarkExtensions, fromMarkdownExtensions, toMarkdownExtensions) {\n  const data = self.data();\n\n  add('micromarkExtensions', micromarkExtensions);\n  add('fromMarkdownExtensions', fromMarkdownExtensions);\n  add('toMarkdownExtensions', toMarkdownExtensions);\n\n  /**\n  * @param {string} field\n  * @param {unknown} value\n  */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n\n\nexport function assert(bool, msg) {\n  if (!bool) {\n    throw new Error(msg);\n  }\n}","import {splice} from 'micromark-util-chunked'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {all} from 'remark-rehype';\nimport {visit} from 'unist-util-visit';\nimport { addRemarkExtension, assert } from './helpers';\nimport {h} from 'hastscript';\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * \n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n \n\n/**\n * @returns {Extension}\n */\nfunction footnoteSyntax() {\n  /** @type {Extension} */\n  return {\n    _hiddenFootnoteSupport: {},\n    text: {\n      [codes.caret]: {\n        tokenize: tokenizeInlineFootnoteStart, \n        resolveAll: resolveAllFootnote\n      },\n      [codes.rightSquareBracket]: {\n        add: 'after',\n        tokenize: tokenizeInlineFootnoteEnd,\n        resolveAll: resolveAllFootnote,\n        resolveTo: resolveToFootnoteEnd\n      },  \n    }\n  };\n\n  /** @type {Tokenizer} */\n  function tokenizeInlineFootnoteStart(effects, ok, nok) {\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.caret, 'expected `^`');\n      effects.enter('inlineFootnoteStart');\n      effects.enter('inlineFootnoteMarker');\n      effects.consume(code);\n      effects.exit('inlineFootnoteMarker');\n      return inlineFootnoteStart;\n    }\n\n    /** @type {State} */\n    function inlineFootnoteStart(code) {\n      if (code !== codes.leftSquareBracket) {\n        return nok(code);\n      }\n\n      effects.enter('inlineFootnoteStartMarker');\n      effects.consume(code);\n      effects.exit('inlineFootnoteStartMarker');\n      effects.exit('inlineFootnoteStart');\n      return ok;\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeInlineFootnoteEnd(effects, ok, nok) {\n    const self = this;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.rightSquareBracket, 'expected `]`');\n      let index = self.events.length;\n      /** @type {boolean|undefined} */\n      let hasStart;\n\n      // Find an opening.\n      while (index--) {\n        if (self.events[index][1].type === 'inlineFootnoteStart') {\n          hasStart = true;\n          break;\n        }\n      }\n\n      if (!hasStart) {\n        return nok(code);\n      }\n\n      effects.enter('inlineFootnoteEnd');\n      effects.enter('inlineFootnoteEndMarker');\n      effects.consume(code);\n      effects.exit('inlineFootnoteEndMarker');\n      effects.exit('inlineFootnoteEnd');\n      return ok;\n    }\n  }\n\n  /**\n   * Remove remaining note starts.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllFootnote(events) {\n    let index = -1;\n    /** @type {Token} */\n    let token;\n\n    while (++index < events.length) {\n      token = events[index][1];\n\n      if (events[index][0] === 'enter' && token.type === 'inlineFootnoteStart') {\n        token.type = 'data';\n        // Remove the two marker (`^[`).\n        events.splice(index + 1, 4);\n      }\n    }\n\n    return events;\n  }\n\n  /** @type {Resolver} */\n  function resolveToFootnoteEnd(events, context) {\n    let index = events.length - 4;\n    /** @type {Token} */\n    let token;\n    /** @type {number} */\n    let openIndex;\n\n    // Find an opening.\n    while (index--) {\n      token = events[index][1];\n\n      // Find where the note starts.\n      if (events[index][0] === 'enter' && token.type === 'inlineFootnoteStart') {\n        openIndex = index;\n        break;\n      }\n    }\n\n    // @ts-expect-error It’s fine.\n    assert(openIndex !== undefined, 'expected `openIndex` to be found');\n\n    /** @type {Token} */\n    const group = {\n      type: 'inlineFootnote',\n      start: Object.assign({}, events[openIndex][1].start),\n      end: Object.assign({}, events[events.length - 1][1].end),\n    }\n\n    const text = {\n      type: 'inlineFootnoteText',\n      start: Object.assign({}, events[openIndex + 4][1].end),\n      end: Object.assign({}, events[events.length - 3][1].start),\n    }\n\n    const note = [\n      ['enter', group, context],\n      events[openIndex + 1],\n      events[openIndex + 2],\n      events[openIndex + 3],\n      events[openIndex + 4],\n      ['enter', text, context]\n    ];\n\n    splice(\n      note,\n      note.length,\n      0,\n      resolveAll(\n        context.parser.constructs.insideSpan.null,\n        events.slice(openIndex + 6, -4),\n        context\n      )\n    );\n\n    note.push(\n      ['exit', text, context],\n      events[events.length - 3],\n      events[events.length - 2],\n      ['exit', group, context]\n    );\n\n    splice(events, index, events.length - index, note);\n\n    return events;\n  }\n}\n\n\n\nfunction footnoteFromMarkdown() {\n  /** @type {FromMarkdownExtension} */\n  return {\n    enter: {\n      inlineFootnote: enterInlineFootnote,\n    },\n    exit: {\n      inlineFootnote: exitInlineFootnote,\n    }\n  };\n\n  function enterInlineFootnote(token) {\n    this.enter({type: 'footnote', children: []}, token);\n  }\n\n  function exitInlineFootnote(token) {\n    this.exit(token);\n  }\n}\n\nfunction footnoteToMarkdown() {\n  return {\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnote},\n  };\n\n  function footnote(node, _, context) {\n    const exit = context.enter('footnote');\n    const subexit = context.enter('label');\n    const value = '^[' + containerPhrasing(node, context, {before: '[', after: ']'}) + ']';\n    subexit();\n    exit();\n    return value;\n  }\n};\n\n\n\nexport function remarkFootnotes() {\n  addRemarkExtension(this, footnoteSyntax(), footnoteFromMarkdown(), footnoteToMarkdown());\n}\n\n\n/**\n * Render footnotes as <footnote>content</footnote>\n */\nexport const remarkToRehypeHandlersFootnotes = {\n  footnote(h, node) {\n    return h(node, 'footnote', all(h, node))\n  },\n  footnoteDefinition(h, node) {\n    return null;\n  },\n  footnoteReference(h, node) {\n    return null;\n  },\n};\n\n\nexport function rehypeFootnoteSeparator() {\n  // add a footnote call separator tag between consecutive <footnote> tags\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    if (node.tagName === 'footnote' && parent.children[index + 1]?.tagName === 'footnote') {\n      parent.children.splice(index + 1, 0, h('sup', {class: 'footnote-call-separator'}));\n    }\n  })\n}\n\n\nexport function rehypeFootnoteSeparatorPreview() {\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    // Remove link from footnote call\n    if (node.tagName !== 'sup' || node.children.length !== 1 || !node.children[0]?.properties?.dataFootnoteRef) {\n      return;\n    }\n    node.children = node.children[0].children;\n\n    // Add footnote call separator\n    const nextSibling = parent.children[index + 1];\n    if (nextSibling?.tagName !== 'sup' || nextSibling.children.length !== 1 || !nextSibling.children[0]?.properties?.dataFootnoteRef) {\n      return;\n    }\n    parent.children.splice(index + 1, 0, h('sup', {class: 'footnote-call-separator'}, [',']));\n  })\n}","import { gfmStrikethrough } from 'micromark-extension-gfm-strikethrough';\nimport { gfmStrikethroughFromMarkdown, gfmStrikethroughToMarkdown } from 'mdast-util-gfm-strikethrough';\nimport { gfmTaskListItem } from 'micromark-extension-gfm-task-list-item';\nimport { gfmTaskListItemFromMarkdown, gfmTaskListItemToMarkdown } from 'mdast-util-gfm-task-list-item';\nimport { addRemarkExtension } from './helpers';\n\n\nexport function remarkStrikethrough() {\n  addRemarkExtension(this, gfmStrikethrough(), gfmStrikethroughFromMarkdown, gfmStrikethroughToMarkdown);\n}\n\n\nexport function remarkTaskListItem() {\n  addRemarkExtension(this, gfmTaskListItem, gfmTaskListItemFromMarkdown, gfmTaskListItemToMarkdown);\n}\n","import {visit} from 'unist-util-visit';\n\n/**\n * Add target=\"_blank\" to links.\n */\nexport function rehypeLinkTargetBlank() {\n  return tree => {\n    visit(tree, 'element', node => {\n      if (node.tagName === 'a' && !(node.properties.href || '#').startsWith('#')) {\n        node.properties.target = '_blank';\n        node.properties.rel = 'nofollow noopener noreferrer';\n      }\n    });\n  }\n}\n\n/**\n * Convert HTML attributes to inline CSS styles.\n */\nexport function rehypeConvertAttrsToStyle() {\n  const convertAttrs = {\n    'width': 'width', \n    'height': 'height'\n  };\n\n  return tree => {\n    visit(tree, 'element', node => {\n      for (const [attrName, styleName] of Object.entries(convertAttrs)) {\n        if (node.properties[attrName]) {\n          let style = (node.properties.style || '');\n          if (style && style[style.length - 1] !== ';') {\n            style += ';'\n          }\n          style += styleName + ':' + node.properties[attrName] + ';';\n          node.properties.style = style;\n          node.properties[attrName] = undefined;\n        }\n      }\n    });\n  }\n}\n\n\nexport function addClass(node, className) {\n  if (!node.properties.className) {\n    node.properties.className = [];\n  }  \n  if (Array.isArray(className)) {\n    node.properties.className.push(...className);\n  } else {\n    node.properties.className.push(className);\n  }\n}\n\n\nexport function rehypeRewriteImageSources({rewriteImageSource}) {\n  return tree => visit(tree, 'element', node => {\n    if (node.tagName === 'img' && node.properties.src && rewriteImageSource) {\n      node.properties.src = rewriteImageSource(node.properties.src);\n    }\n  });\n}\n\n\nexport function rehypeRewriteFileLinks({ rewriteFileUrl }) {\n  return tree => visit(tree, 'element', node => {\n    if (node.tagName === 'a' && node.properties?.href?.startsWith('/files/') && rewriteFileUrl) {\n      node.properties.href = rewriteFileUrl(node.properties.href);\n      node.properties.download = true;\n      addClass(node, ['file-download-preview', 'v-icon', 'mdi', 'mdi-file-download']);\n    }\n  });\n}\n\n\nexport function rehypeTemplates() {\n  return tree => visit(tree, 'element', node => {\n    if (node.tagName === 'template') {\n      node.children = node.content?.children || [];\n      node.tagName = 'span';\n    }\n  })\n}\n","import {codes} from 'micromark-util-symbol/codes.js';\nimport {factoryAttributes} from 'micromark-extension-directive/lib/factory-attributes.js';\nimport {parseEntities} from 'parse-entities';\nimport {visit} from 'unist-util-visit';\nimport { addRemarkExtension } from './helpers';\n\n\nfunction attrsSyntax() {\n  return {\n    name: 'attrs',\n    text: {\n      [codes.leftCurlyBrace]: {\n        tokenize: tokenizeAttributes,\n      }\n    }\n  };\n\n  function tokenizeAttributes(effects, ok, nok) {\n    // Always a `{`\n    return factoryAttributes(\n      effects,\n      ok,\n      nok,\n      'textAttributes',\n      'textAttributesMarker',\n      'textAttribute',\n      'textAttributeId',\n      'textAttributeClass',\n      'textAttributeName',\n      'textAttributeInitializerMarker',\n      'textAttributeValueLiteral',\n      'textAttributeValue',\n      'textAttributeValueMarker',\n      'textAttributeValueData'\n    )\n  }\n};\n\n\nfunction attrsFromMarkdown() {\n  return {\n    transforms: [transformAttributesAttachToElements],\n    enter: {\n      textAttributes: enterAttributes,\n    },\n    exit: {\n      textAttributes: exitAttributes,\n      textAttributeClassValue: exitAttributeClassValue,\n      textAttributeIdValue: exitAttributeIdValue,\n      textAttributeName: exitAttributeName,\n      textAttributeValue: exitAttributeValue,\n    }\n  };\n\n  function enterAttributes(token) {\n    this.setData('directiveAttributes', []);\n    this.enter({type: 'attributes', attrs: {}, attrsString: ''}, token);\n    this.buffer();\n  }\n\n  function exitAttributeIdValue(token) {\n    const list = this.getData('directiveAttributes');\n    list.push(['id', parseEntities(this.sliceSerialize(token))])\n  }\n\n  function exitAttributeClassValue(token) {\n    const list = this.getData('directiveAttributes');\n    list.push(['class', parseEntities(this.sliceSerialize(token))])\n  }\n\n  function exitAttributeValue(token) {\n    const list = this.getData('directiveAttributes');\n    list[list.length - 1][1] = parseEntities(this.sliceSerialize(token))\n  }\n\n  function exitAttributeName(token) {\n    // Attribute names in CommonMark are significantly limited, so character\n    // references can’t exist.\n    this.getData('directiveAttributes').push([this.sliceSerialize(token), ''])\n  }\n\n  function exitAttributes(token) {\n    const cleaned = {};\n    for (const attribute of this.getData('directiveAttributes')) {\n      if (attribute[0] === 'class' && cleaned.class) {\n        cleaned.class += ' ' + attribute[1];\n      } else {\n        cleaned[attribute[0]] = attribute[1];\n      }\n    }\n  \n    this.setData('directiveAttributes')\n    this.resume(); // Drop EOLs\n\n    const node = this.stack[this.stack.length - 1];\n    node.attrs = cleaned;\n    node.attrsString = this.sliceSerialize(token);\n    this.exit(token);\n  }\n\n  function transformAttributesAttachToElements(tree) {\n    // Attach attributes to elements or convert to text\n    visit(tree, (node, index, parent) => {\n      if (node.type === 'attributes') {\n        const prevNode = index > 0 ? parent.children[index - 1] : null;\n        if (prevNode && prevNode.type !== 'text') {\n          // Attach attributes to previous element e.g. ![img](img.png){width=\"50%\"}, **bold**{.styled}, but not \"**bold** {.not-styled}\"\n          prevNode.data = {...prevNode.data, hProperties: node.attrs};\n        } else {\n          // Could not attach to any node: convert attributes to text\n          node.type = 'text';\n          node.value = node.attrsString;\n          delete node.attrs;\n          delete node.attrsString;\n        }\n      }\n    });\n  }\n}\n\n\nfunction attrsToMarkdown() {\n  return {\n    handlers: {\n      attributes\n    }\n  };\n\n  function attributes(node, _, context) {\n    const exit = context.enter('attributes');\n    const value = node.attrsString || Object.entries(node.attrs).map(([k, v]) => {\n      if (k === 'id') { return '#' + v }\n      else if (k === 'class') { return v.split(' ').map(c => '.' + c).join(' ')}\n      else { return `${k}=${v}`; }\n    }).join(' ');\n    exit();\n    return value;\n  }\n}\n\nexport const remarkToRehypeAttrs = {\n  attributes(h, node) {\n    // Remove attributes nodes\n    return null;\n  }\n}\n\nexport function remarkAttrs() {\n  addRemarkExtension(this, attrsSyntax(), attrsFromMarkdown(), attrsToMarkdown());\n}\n\n","import { addRemarkExtension } from \"./helpers\";\nimport {checkQuote} from 'mdast-util-to-markdown/lib/util/check-quote.js'\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {all} from 'remark-rehype';\nimport {normalizeUri} from 'micromark-util-sanitize-uri';\n\n\nfunction figureFromMarkdown() {\n  // Extend default image formatter from mdast-util-from-markdown to support child markdown text\n  return {\n    enter: {\n      image: enterImage,\n    }, \n    exit: {\n      label: exitLabel,\n    }\n  };\n\n  function enterImage(token) {\n    this.enter({type: 'image', title: null, url: '', alt: null, children: []}, token);\n  }\n\n\n  /**\n   * Label for link or image\n   */\n  function exitLabel(token) {\n    const fragment = /** @type {Fragment} */ (this.stack[this.stack.length - 1]);\n    const value = this.resume();\n    const node =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */ (\n        this.stack[this.stack.length - 1]\n      );\n\n    // Assume a reference.\n    this.setData('inReference', true);\n\n    // @ts-expect-error: Assume static phrasing content.\n    node.children = fragment.children;\n    if (node.type === 'image') {\n      node.alt = value;\n    }\n  }\n}\n\n\nfunction figureToMarkdown() {\n  image.peek = () => '!';\n\n  return {\n    handlers: {\n      image\n    },\n  };\n\n  function image(node, _, context, safeOptions) {\n    const quote = checkQuote(context);\n    const suffix = quote === '\"' ? 'Quote' : 'Apostrophe';\n    const exit = context.enter('image');\n    let subexit = context.enter('label');\n    const tracker = track(safeOptions);\n    let value = tracker.move('![');\n    value += tracker.move(\n      containerPhrasing(node, context, {\n        before: value,\n        after: '](',\n        ...tracker.current()\n      })\n    );\n    value += tracker.move('](');\n\n    subexit();\n\n    if (\n      // If there’s no url but there is a title…\n      (!node.url && node.title) ||\n      // If there are control characters or whitespace.\n      /[\\0- \\u007F]/.test(node.url)\n    ) {\n      subexit = context.enter('destinationLiteral');\n      value += tracker.move('<');\n      value += tracker.move(\n        safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n      );\n      value += tracker.move('>');\n    } else {\n      // No whitespace, raw is prettier.\n      subexit = context.enter('destinationRaw');\n      value += tracker.move(\n        safe(context, node.url, {\n          before: value,\n          after: node.title ? ' ' : ')',\n          ...tracker.current()\n        })\n      );\n    }\n\n    subexit();\n\n    if (node.title) {\n      subexit = context.enter('title' + suffix);\n      value += tracker.move(' ' + quote);\n      value += tracker.move(\n        safe(context, node.title, {\n          before: value,\n          after: quote,\n          ...tracker.current()\n        })\n      );\n      value += tracker.move(quote);\n      subexit();\n    }\n\n    value += tracker.move(')');\n    exit();\n\n    return value;\n  }\n  \n}\n\n\nexport function remarkFigure() {\n  addRemarkExtension(this, {}, figureFromMarkdown(), figureToMarkdown());\n}\n\n\nexport const remarkToRehypeHandlersFigure = {\n  image(h, node) {\n    // only add attributes to <img> tag, not to <figure>\n    const attrs = (node.data || {}).hProperties || {};\n    if (!node.data) {\n      node.data = {};\n    }\n    node.data.hProperties = {};\n\n    return h(node, 'figure', [\n      h(node, 'img', {src: normalizeUri(node.url), alt: node.alt, ...attrs}),\n      ...(node.children.length > 0 ? [h(node, 'figcaption', all(h, node))] : [])\n    ]);\n  }\n};\n","import { gfmTable } from 'micromark-extension-gfm-table';\nimport { gfmTableFromMarkdown, gfmTableToMarkdown } from 'mdast-util-gfm-table';\nimport { addRemarkExtension } from './helpers';\nimport { visit } from 'unist-util-visit';\nimport { all } from 'remark-rehype';\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\n\n\nexport function remarkTables() {\n  addRemarkExtension(this, gfmTable, gfmTableFromMarkdown, gfmTableToMarkdown());\n}\n\n\nfunction tableCaptionFromMarkdown() {\n  return {\n    transforms: [transformTableCaption]\n  };\n\n  function transformTableCaption(tree) {\n    visit(tree, (node, index, parent) => {\n      if (node.type === 'table') {\n        const captionBlock = parent.children[index + 1];\n        if (captionBlock && captionBlock.type === 'paragraph' && captionBlock.children.length > 0 && captionBlock.children[0].type === 'text') {\n          const captionText = captionBlock.children[0];\n          let captionPrefixLength = 0;\n          if (captionText.value.startsWith(':')) {\n            captionPrefixLength = 1;\n          } else if (captionText.value.startsWith('Table:')) {\n            captionPrefixLength = 6;\n          }\n\n          \n          if (captionPrefixLength) {\n            const captionVal = captionText.value.slice(captionPrefixLength);\n            const captionValTrimmed = captionVal.trimStart();\n            captionPrefixLength += captionVal.length - captionValTrimmed.length;\n\n            captionText.value = captionText.value.slice(captionPrefixLength);\n            captionText.position.start.column += captionPrefixLength;\n            captionText.position.start.offset += captionPrefixLength;\n\n            // Mark block as table caption, but do not move caption into table (this is done when transforming to rehype)\n            captionBlock.type = 'tableCaption';\n          }\n        }\n      }\n    });\n  }\n}\n\n\nfunction tableCaptionToMarkdown() {\n  return {\n    handlers: {tableCaption},\n  };\n\n  function tableCaption(node, _, context, safeOptions) {\n    const exit = context.enter('tableCaption');\n    const subexit = context.enter('phrasing');\n    const value = 'Table: ' + containerPhrasing(node, context, safeOptions);\n    subexit();\n    exit();\n    return value;\n  }\n}\n\n\nexport function remarkTableCaptions() {\n  addRemarkExtension(this, {}, tableCaptionFromMarkdown(), tableCaptionToMarkdown());\n}\n\n\nexport const remarkToRehypeHandlersTableCaptions = {\n  tableCaption(h, node) {\n    return h(node, 'caption', all(h, node));\n  }\n};\n\nexport function rehypeTableCaptions() {\n  return tree =>\n    visit(tree, 'element', (node, index, parent) => {\n      if (node.tagName === 'caption') {\n        // Move table caption tag into HTML table\n        const tableNode1 = parent.children[index - 1];\n        const tableNode2 = parent.children[index - 2];\n        if (tableNode1 && tableNode1.tagName === 'table') {\n          tableNode1.children.push(node);\n          parent.children.splice(index, 1);\n        } else if (tableNode1 && tableNode1.type === 'text' && tableNode1.value === '\\n' && tableNode2.tagName === 'table') {\n          tableNode2.children.push(node);\n          parent.children.splice(index, 1);\n        }\n      }\n    });\n}","import { micromarkEventsToTree, parseMicromarkEvents } from './micromark-utils.js';\n\n\nfunction createBlockSeparator(pos) {\n  return {\n    type: 'annotatedTextBlockSeparator', \n    text: '', \n    children: [],\n    enter: {\n      type: 'annotatedTextBlockSeparator',\n      start: pos,\n      end: pos,\n    },\n    exit: {\n      type: 'annotatedTextBlockSeparator',\n      start: pos,\n      end: pos,\n    },\n  };\n}\n\nexport function extractLeafNodesFromMicromarkTree(tree, {interpretAsLeafNodes = [], interpretAsLeafNodesFns = {}, wrapTypesWithBlockSeparators = []}) {\n  const leafNodes = [];\n  collectLeafNodes(tree);\n  return leafNodes;\n\n  function collectLeafNodes(t) {\n    for (const n of t) {\n      const wrapWithSeparators = wrapTypesWithBlockSeparators.includes(n.type);\n      if (wrapWithSeparators) {\n        leafNodes.push(createBlockSeparator(n.enter.start));\n      }\n\n      if (n.children.length === 0 || interpretAsLeafNodes.includes(n.type) || interpretAsLeafNodesFns[n.type]?.(n)) {\n        leafNodes.push(n);\n      } else {\n        collectLeafNodes(n.children);\n      }\n\n      if (wrapWithSeparators) {\n        leafNodes.push(createBlockSeparator(n.exit.end));\n      }\n    }\n  } \n}\n\n\n\nfunction micromarkToAnnotatedText(text, events) {\n  const tree = micromarkEventsToTree(text, events);\n  // console.log('micromark tree', tree);\n\n  // Add separators between blocks, such that blocks are always interpreted as separate\n  for (let i = tree.length - 1; i >= 0; i--) {\n    tree.splice(i, 0, createBlockSeparator(tree[i].enter.start));\n  }\n\n  // extract leaf nodes of tree => this is a sequence of all the text tokens\n  const leafNodes = extractLeafNodesFromMicromarkTree(tree, {\n    interpretAsLeafNodes: ['codeFenced', 'codeText', 'textAttributes', 'inlineFootnote', 'table', 'resource', 'templateVariable'],\n    interpretAsLeafNodesFns: {\n      'labelText': n => n.children.length === 0,\n    },\n    wrapTypesWithBlockSeparators: ['image'],\n  });\n\n  // console.log('annotatedText.leafNodes', leafNodes)\n\n  // convert leaf nodes to annotatedText => either text or markup\n  // TODO: support table caption in micromark (instead of mdast)\n  const textTypes = ['data', 'lineEnding', 'lineEndingBlank'];\n  const markupTypesInterpretAs = {\n    'listItemMarker': '\\n\\n',\n    'codeFenced': '\\n\\n',\n    'annotatedTextBlockSeparator': '\\n\\n',\n    'codeText': '`code`',\n    'templateVariable': '`code`',\n    'labelText': '`code`',\n  };\n  const annotatedText = [];\n  for (const n of leafNodes) {\n    if (n.type === 'lineEnding') {\n      // Workaround for micromark bug: the end position of lineEnding elements is wrong (overlaps with next element)\n      annotatedText.push({\n        text: '\\n',\n        offset: n.enter.start.offset,\n      });\n    } else if (textTypes.includes(n.type)) {\n      annotatedText.push({\n        text: n.text,\n        offset: n.enter.start.offset,\n      });\n    } else {\n      annotatedText.push({\n        markup: n.text,\n        offset: n.enter.start.offset,\n        interpretAs: markupTypesInterpretAs[n.type] || '',\n      });\n    }\n  }\n  return annotatedText;\n}\n\n\nexport function annotatedTextParse() {\n  const micromarkExtensions = this.data('micromarkExtensions') || [];\n  this.Parser = parser;\n\n  function parser(text) {\n    const events = parseMicromarkEvents(text, {extensions: micromarkExtensions});\n    return micromarkToAnnotatedText(text, events);\n  }\n}","import { codes } from 'micromark-util-symbol/codes.js';\nimport { addRemarkExtension, assert } from './helpers';\n\n\nfunction templateVariableSyntax() {\n  return {\n    text: {\n      [codes.leftCurlyBrace]: {\n        tokenize: tokenizeTemplateVariable,\n      },\n    }\n  };\n\n  function tokenizeTemplateVariable(effects, ok, nok) {\n    let closeBraceCount = 0;\n    return start;\n\n    function start(code) {\n      assert(code === codes.leftCurlyBrace, 'expected `{`}');\n      effects.enter('templateVariable');\n      effects.consume(code);\n      return start2;\n    }\n    function start2(code) {\n      if (code !== codes.leftCurlyBrace) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return between;\n    }\n    function between(code) {\n      if (code === codes.eof) {\n        return nok(code);\n      } else if (code === codes.rightCurlyBrace) {\n        // Closing sequence or part of content?\n        closeBraceCount = 0;\n        return sequenceClose(code);\n      } else {\n        effects.consume(code);\n        return between;\n      }\n    }\n    function sequenceClose(code) {\n      if (code === codes.rightCurlyBrace) {\n        effects.consume(code);\n        closeBraceCount += 1;\n\n        if (closeBraceCount === 2) {\n          // Dummy close events, rewritten in resolveTemplateVariable\n          effects.exit('templateVariable');\n          return ok(code);\n        } else {\n          return sequenceClose;\n        }\n      } else {\n        return between(code);\n      }\n    }\n  }\n\n}\n\n\nfunction templateVariableFromMarkdown() {\n  return {\n    enter: {\n      templateVariable: enterTemplateVariable,\n    },\n    exit: {\n      templateVariable: exitTemplateVariable,\n    }\n  };\n\n  function enterTemplateVariable(token) {\n    this.enter({type: 'templateVariable', value: ''}, token);\n  }\n  function exitTemplateVariable(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.value = this.sliceSerialize(token); \n    this.exit(token);\n  }\n}\n\nfunction templateVariableToMarkdown() {\n  return {\n    handlers: {\n      templateVariable,\n    } \n  };\n\n  function templateVariable(node, _, context) {\n    const exit = context.enter('templateVariable');\n    const value = node.value;\n    exit();\n    return value;\n  }\n}\n\n\nexport function remarkTemplateVariables() {\n  addRemarkExtension(this, templateVariableSyntax(), templateVariableFromMarkdown(), templateVariableToMarkdown());\n}\n","import { codes } from 'micromark-util-symbol/codes.js';\nimport { addRemarkExtension } from \"./helpers\";\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\n\n\nfunction todoSyntax() {\n  return {\n    name: 'todo',\n    text: {\n      [codes.uppercaseT]: {\n        tokenize: tokenizeTodo,\n      },\n      [codes.lowercaseT]: {\n        tokenize: tokenizeTodo,\n      },\n    }\n  };\n\n  function tokenizeTodo(effects, ok, nok) {\n    return startT;\n\n    function startT(code) {\n      effects.enter('todo');\n      effects.enter('data');\n      effects.consume(code);\n      return middleO;\n    }\n    function middleO(code) {\n      if (![codes.uppercaseO, codes.lowercaseO].includes(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return middleDorDash;\n    }\n    function middleDorDash(code) {\n      if (code == codes.dash) {\n        effects.consume(code);\n        return middleD;\n      }\n      return middleD(code);\n    }\n    function middleD(code) {\n      if (![codes.uppercaseD, codes.lowercaseD].includes(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return endO;\n    }\n    function endO(code) {\n      if (![codes.uppercaseO, codes.lowercaseO].includes(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      effects.exit('data');\n      effects.exit('todo');\n      return ok(code);\n    }\n  }\n}\n\n\nfunction todoFromMarkdown() {\n  return {\n    enter: {\n      todo: enterTodo,\n    },\n    exit: {\n      todo: exitTodo,\n    }\n  };\n\n  function enterTodo(token) {\n    this.enter({type: 'todo', children: [], data: {hName: 'span', hProperties: {class: 'todo'}}}, token);\n  }\n  function exitTodo(token) {\n    this.exit(token);\n  }\n}\n\nfunction todoToMarkdown() {\n  return {\n    handlers: {\n      todo,\n    } \n  };\n\n  function todo(node, _, context, safeOptions) {\n    const exit = context.enter('todo');\n    const value = containerPhrasing(node, context, safeOptions);\n    exit();\n    return value;\n  }\n}\n\n\nexport function remarkTodoMarker() {\n  addRemarkExtension(this, todoSyntax(), todoFromMarkdown(), todoToMarkdown());\n}\n","import { visit } from 'unist-util-visit';\nimport { toString } from 'hast-util-to-string';\nimport { camelCase } from 'lodash';\nimport { lowlight } from 'lowlight/lib/all'\nimport { unified } from 'unified';\nimport rehypeParse from 'rehype-parse';\nimport { addClass } from './rehypePlugins';\n\n\nfunction getLanguage(node) {\n  return (node.properties?.className || [])\n    .filter(c => c.startsWith('language-'))\n    .map(c => c.slice(9).toLowerCase())\n    [0] || 'none';\n}\n\nfunction highlightSyntax(code, node) {\n  const language = getLanguage(node);\n  \n  addClass(node, 'hljs');\n  try {\n    return lowlight.highlight(language, code);\n  } catch (error) {\n    if (!/Unknown language/.test(error)) {\n      throw error;\n    }\n  }\n  return {\n    type: 'root',\n    children: [{type: 'text', value: code}]\n  };\n}\n\nfunction parseMeta(metaLine) {\n  const meta = Object.fromEntries(\n    Array.from(metaLine.matchAll(/(?<name>[a-zA-Z0-9\\-]+)(?:=\"(?<value>[^\"]+)\")?/g))\n      .map(m => [camelCase(m.groups.name), m.groups.value || null])\n  );\n  if (meta.highlightManual !== undefined) {\n    meta.highlightManual = meta.highlightManual || '§';\n  }\n  if (meta.lineNumbers !== undefined) {\n    meta.lineNumbers = Number.parseInt(meta.lineNumbers) || 1;\n  }\n  return meta;\n}\n\nfunction parseManualHighlightAreas(code, meta) {\n  const highlightInfos = []\n  if (!meta.highlightManual || meta.highlightManual.length !== 1) {\n      return {code, highlightInfos};\n  }\n\n  const highlightMarkerRe = `\\\\${meta.highlightManual}[^\\\\${meta.highlightManual}\\\\R]*\\\\${meta.highlightManual}`;\n  const highlightedAreaRe = new RegExp(`(${highlightMarkerRe})([^\\\\${meta.highlightManual}]*)(${highlightMarkerRe})`, 'g');\n  const parts = code.split(highlightedAreaRe);\n  let codeNew = '';\n  for (let i = 0; i < parts.length; i += 4) {\n    codeNew += parts[i];\n    if (i + 3 < parts.length) {\n      const highlightInfo = {\n        startMarker: parts[i + 1].slice(1, parts[i + 1].length - 1),\n        startMarkerPos: codeNew.length,\n        endMarker: parts[i + 3].slice(1, parts[i + 3].length - 1),\n        endMarkerPos: 0,\n      };\n      codeNew += parts[i + 2];\n      highlightInfo.endMarkerPos = codeNew.length;\n      highlightInfos.push(highlightInfo);\n    }\n  }\n\n  return {code: codeNew, highlightInfos};\n}\n\n\nfunction splitTreeAtPosition(tree, splitPos) {\n  return {\n    ...tree,\n    children: processChildren(tree.children, 0).flat(),\n  }\n\n  function processChildren(children, currentPos) {\n    const childrenLeft = [];\n    const childrenRight = [];\n\n    for (const c of children) {\n      for (const pc of processNode(c, currentPos)) {\n        if (currentPos < splitPos) {\n          childrenLeft.push(pc);\n        } else {\n          childrenRight.push(pc);\n        }\n        currentPos += toString(pc).length;\n      }\n    }\n    return [childrenLeft, childrenRight];\n  }\n\n  function processNode(node, currentPos) {\n    const nodeLength = toString(node).length;\n    if (currentPos < splitPos && currentPos + nodeLength > splitPos) {\n      if (node.type === 'text') {\n        return [\n          {...node, value: node.value.slice(0, splitPos - currentPos)},\n          {...node, value: node.value.slice(splitPos - currentPos)},\n        ];\n      } else {\n        const [childrenLeft, childrenRight] = processChildren(node.children, currentPos)\n        return [\n          {...node, children: childrenLeft},\n          {...node, children: childrenRight},\n        ];\n      }\n    }\n\n    return [node];\n  }\n}\n\n\nfunction wrapTreeAreas(tree, wrapInfos) {\n  for (const wi of wrapInfos) {\n    // Split highlighted HTML tree at the positions where manual highlight markers will be inserted\n    tree = splitTreeAtPosition(tree, wi.startMarkerPos);\n    tree = splitTreeAtPosition(tree, wi.endMarkerPos);\n  }\n\n  // Insert manual highlighting markers\n  const children = [];\n  for (let ci = 0, wii = 0, currentPos = 0; ci < tree.children.length; currentPos += toString(tree.children[ci]).length, ci++) {\n    const c = tree.children[ci];\n    let wi = wrapInfos[wii];\n\n    if (wi && (currentPos >= wi.startMarkerPos && currentPos + toString(c).length <= wi.endMarkerPos)) {\n      wi.children = (wi.children || []).concat([c]);\n\n      if (currentPos + toString(c).length == wi.endMarkerPos) {\n        visit(wi.markerTree, 'element', (node, index, parent) => {\n          if (node.tagName === 'content-placeholder') {\n            parent.children.splice(index, 1, ...wi.children);\n          }\n        });\n        children.push(...wi.markerTree.children);\n        wii += 1;\n      }\n    } else if (wi && (currentPos === wi.startMarkerPos && currentPos === wi.endMarkerPos)) {\n      visit(wi.markerTree, 'element', (node, index, parent) => {\n        if (node.tagName === 'content-placeholder') {\n          parent.children.splice(index, 1);\n        }\n      });\n      children.push(...wi.markerTree.children);\n      children.push(c);\n      wii += 1;\n    } else {\n      children.push(c);\n    }\n  }\n\n  tree.children = children;\n  return tree;\n}\n\n\nfunction applyManualHighlighting(tree, highlightInfos) {\n  for (const hi of highlightInfos) {\n    // Parse marker as HTML\n    hi.markerTree = unified()\n      .use(rehypeParse, {fragment: true})\n      .parse((hi.startMarker || '<mark>') + '<content-placeholder />' + (hi.endMarker || '</mark>'))\n  }\n\n  return wrapTreeAreas(tree, highlightInfos);\n}\n\n\nfunction splitIntoLines(tree) {\n  const lines = [];\n  let currentPos = 0;\n  for (const line of toString(tree).split('\\n')) {\n    lines.push({\n      startMarkerPos: currentPos,\n      endMarkerPos: currentPos + line.length,\n      markerTree: {\n        type: 'root',\n        children: [\n          {\n            type: 'element',\n            tagName: 'span',\n            properties: {\n              className: ['code-block-line'],\n              dataLineNumber: lines.length + 1\n            },\n            children: [{type: 'element', tagName: 'content-placeholder', children: []}],\n          }\n        ]\n      }\n    });\n    currentPos += line.length + 1;\n  }\n  \n  return wrapTreeAreas(tree, lines);\n}\n\n\nexport function rehypeHighlightCode() {\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    if (node.tagName === 'code' && parent.tagName === 'pre') {\n      addClass(parent, 'code-block');\n\n      const meta = parseMeta(node.data?.meta || '');\n\n      // Manual highlighting\n      const {code, highlightInfos} = parseManualHighlightAreas(toString(node), meta);\n\n      // Syntax highlighting\n      let tree = highlightSyntax(code, node);\n\n      // Add manual highighting\n      if (highlightInfos.length > 0) {\n        tree = applyManualHighlighting(tree, highlightInfos);\n      }\n\n      // Add line infos\n      tree = splitIntoLines(tree);\n\n      node.children = tree.children;\n    } else if (node.tagName === 'code') {\n      addClass(node, 'code-inline');\n    }\n  }); \n}\n","\nimport { unified } from 'unified';\nimport remarkParse from 'remark-parse';\nimport remarkRehype from 'remark-rehype';\nimport rehypeStringify from 'rehype-stringify';\nimport rehypeRaw from 'rehype-raw';\nimport 'highlight.js/styles/default.css';\n\nimport { remarkFootnotes, remarkToRehypeHandlersFootnotes, rehypeFootnoteSeparator, rehypeFootnoteSeparatorPreview } from './mdext/footnotes.js';\nimport { remarkStrikethrough, remarkTaskListItem } from './mdext/gfm.js';\nimport { rehypeConvertAttrsToStyle, rehypeLinkTargetBlank, rehypeRewriteImageSources, rehypeRewriteFileLinks, rehypeTemplates } from './mdext/rehypePlugins.js';\nimport { remarkAttrs, remarkToRehypeAttrs } from './mdext/attrs.js';\nimport { remarkFigure, remarkToRehypeHandlersFigure } from './mdext/image.js';\nimport { remarkTables, remarkTableCaptions, remarkToRehypeHandlersTableCaptions, rehypeTableCaptions } from './mdext/tables.js';\nimport { annotatedTextParse } from './editor/annotatedtext.js';\nimport { remarkTemplateVariables } from './mdext/templates.js';\nimport { remarkTodoMarker } from './mdext/todo.js';\nimport { rehypeHighlightCode } from './mdext/codeHighlight.js';\nimport remarkStringify from 'remark-stringify';\nimport rehypeSanitize, { defaultSchema } from 'rehype-sanitize';\nimport { defaults, merge } from 'lodash';\n\n\nconst rehypeSanitizeSchema = merge({}, defaultSchema, {\n  allowComments: true,\n  clobberPrefix: null,\n  tagNames: ['footnote', 'template'].concat(defaultSchema.tagNames),\n  attributes: {\n    '*': ['className', 'style', 'data*', 'v-if', 'v-for'].concat(defaultSchema.attributes['*']),\n    'a': ['download'].concat(defaultSchema.attributes['a']),\n  }\n});\n\n\nexport function markdownParser() {\n  // TODO: add plugins: \n  // * reference findings: #<finding-id>; current workaround [](#<finding-id>)\n  // * enable autolinks?\n  return unified()\n    .use(remarkFootnotes)\n    .use(remarkTables)\n    .use(remarkTableCaptions)\n    .use(remarkStrikethrough)\n    .use(remarkTaskListItem)\n    .use(remarkTemplateVariables)\n    .use(remarkAttrs)\n    .use(remarkFigure)\n    .use(remarkTodoMarker);\n}\n\n\nexport function formatMarkdown(text) {\n  const md = markdownParser()\n    .use(remarkParse)\n    .use(remarkStringify, {\n      fence: '`',\n      fences: true,\n      bullet: '*',\n      strong: '*',\n      emphasis: '_',\n    });\n  return md.processSync(text).value;\n}\n\nexport function renderMarkdownToHtml(text, {preview = false, rewriteFileSource = null} = {}) {\n  const md = markdownParser()\n      .use(remarkParse)\n      .use(remarkRehype, { \n        allowDangerousHtml: true, \n        footnoteLabelTagName: 'h4',\n        handlers: {\n          ...(preview ? {} : remarkToRehypeHandlersFootnotes),\n          ...remarkToRehypeHandlersFigure,\n          ...remarkToRehypeHandlersTableCaptions,\n          ...remarkToRehypeAttrs,\n        }\n      }) \n      .use(rehypeConvertAttrsToStyle)\n      .use(rehypeTableCaptions)\n      .use(preview ? rehypeFootnoteSeparatorPreview : rehypeFootnoteSeparator)\n      .use(rehypeHighlightCode)\n      .use(rehypeRaw)\n      .use(rehypeLinkTargetBlank)\n      .use(rehypeTemplates)\n      .use(rehypeRewriteImageSources, {rewriteImageSource: rewriteFileSource})\n      .use(rehypeRewriteFileLinks, {rewriteFileUrl: rewriteFileSource})\n      .use(rehypeSanitize, rehypeSanitizeSchema)\n      .use(rehypeStringify);\n\n    // const mdAst = md.parse(text);\n    // console.log('MarkdownAST', mdAst);\n    // const rehypeAst = md.runSync(mdAst);\n    // console.log('RehypeAST', rehypeAst);\n    // const mdHtml = md.stringify(rehypeAst);\n    // console.log('HTML', mdHtml);\n    const mdHtml = md.processSync(text).value;\n    return mdHtml;\n}\n\n\nexport function markdownToAnnotatedText(text) {\n  const md = markdownParser()\n    .use(annotatedTextParse);\n  const at = md.parse(text);\n  // console.log('AnnotatedText', at);\n  return at;\n}\n","import {parse} from 'micromark/lib/parse.js';\nimport {preprocess} from 'micromark/lib/preprocess.js';\nimport {postprocess} from 'micromark/lib/postprocess.js';\nimport {assert} from '../mdext/helpers.js';\n\n\nexport function parseMicromarkEvents(text, config) {\n  return postprocess(parse(config).document().write(preprocess()(text, undefined, true)));\n}\n\nexport function micromarkEventsToTree(text, events) {\n  // console.log('micromark events', events);\n\n  // build enter/exit tree of nested elements\n  const tree = [];\n  const stack = [];\n  for (const [action, node, context] of events) {\n    if (action === 'enter') {\n      const treeNode = {\n        enter: node,\n        exit: null,  \n        children: [],\n\n        type: node.type,\n        text: null,\n      };\n      if (stack.length > 0) {\n        stack[stack.length - 1].children.push(treeNode);\n      } else {\n        tree.push(treeNode);\n      }\n      stack.push(treeNode);\n    } else if (action === 'exit') {\n      const treeNode = stack[stack.length - 1];\n      assert(treeNode.type == node.type);\n\n      treeNode.exit = node;\n      treeNode.text = text.slice(treeNode.enter.start.offset, treeNode.exit.end.offset);\n      stack.splice(stack.length - 1, 1);\n    }\n  }\n  // console.log('micromark tree', tree);\n  return tree;\n}\n"],"sourceRoot":""}