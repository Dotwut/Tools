{"version":3,"sources":["webpack:///./node_modules/vuetify/src/components/VAutocomplete/VAutocomplete.sass?90d2","webpack:///./node_modules/vuetify/src/components/VAutocomplete/VAutocomplete.sass","webpack:///../../../src/components/VAutocomplete/VAutocomplete.ts","webpack:///./components/S/Combobox.vue?7081","webpack:///./components/S/Combobox.vue","webpack:///./components/S/Combobox.vue?cd8a","webpack:///../../../src/components/VCombobox/VCombobox.ts"],"names":["content","__esModule","default","module","i","locals","exports","add","___CSS_LOADER_EXPORT___","___CSS_LOADER_API_IMPORT___","push","defaultMenuProps","VSelectMenuProps","offsetY","offsetOverflow","transition","VSelect","extend","name","props","allowOverflow","type","Boolean","autoSelectFirst","filter","Function","item","queryText","itemText","toLocaleLowerCase","indexOf","hideNoData","menuProps","options","noFilter","searchInput","String","data","lazySearch","this","computed","classes","call","selectedIndex","computedItems","filteredItems","selectedValues","selectedItems","map","getValue","hasDisplayedItems","hideSelected","some","hasItem","length","currentRange","selectedItem","getText","isSearching","internalSearch","allItems","value","getPropertyFromItem","text","get","set","val","$emit","isAnyValueAllowed","isDirty","searchIsDirty","multiple","menuCanShow","isFocused","$_menuProps","contentClass","trim","find","valueComparator","internalValue","listData","items","virtualizedItems","watch","document","addEventListener","onCopy","$refs","input","select","removeEventListener","blur","updateSelf","isMenuActive","hasSlot","oldVal","activateMenu","created","setSearch","destroyed","methods","onFilteredItemsChanged","preSelectedItem","menu","listIndex","setMenuIndex","findIndex","$nextTick","getTiles","onInternalSearchChanged","updateMenuDimensions","updateDimensions","changeSelectedIndex","keyCode","keyCodes","left","right","backspace","delete","deleteCurrentItem","curIndex","curItem","isInteractive","getDisabled","lastIndex","nextIndex","selectItem","setValue","clearableCallback","genInput","VTextField","mergeData","attrs","getObjectValueByPath","autocomplete","domProps","genInputSlot","slot","role","genSelections","onClick","e","onFocus","isAppendInner","target","onInput","badInput","validity","onKeyDown","ctrlKey","home","end","includes","onSpaceDown","onTabDown","onUpDown","preventDefault","setSelectedItems","event","currentItem","currentItemText","clipboardData","_a","setData","_b","outlined","component","_self","staticClass","scopedSlots","staticRenderFns","VAutocomplete","delimiters","Array","returnObject","editingIndex","computedCounterValue","toString","$slots","delimiter","d","endsWith","slice","updateTags","on","paste","onPaste","genChipSelection","index","chip","componentOptions","listeners","dblclick","onChipInput","onEnterDown","getMenuIndex","selectionStart","enter","stopPropagation","updateEditing","undefined","Object","assign","splice","updateCombobox","$scopedSlots","selection","hasChips","menuIndex","itemToSelect","pastedItemText","getData","findExistingIndex"],"mappings":"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","file":"8ba0e89.js","sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../../css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../../../postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../../sass-loader/dist/cjs.js??ref--6-oneOf-1-3!./VAutocomplete.sass\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"50788f08\", content, true, {\"sourceMap\":false});","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../../css-loader/dist/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".v-autocomplete.v-input>.v-input__control>.v-input__slot{cursor:text}.v-autocomplete input{align-self:center}.v-autocomplete.v-select.v-input--is-focused input{min-width:64px}.v-autocomplete:not(.v-input--is-focused).v-select--chips input{max-height:0;padding:0}.v-autocomplete--is-selecting-index input{opacity:0}.v-autocomplete.v-text-field--enclosed:not(.v-text-field--solo):not(.v-text-field--single-line):not(.v-text-field--outlined) .v-select__slot>input{margin-top:24px}.v-autocomplete.v-text-field--enclosed:not(.v-text-field--solo):not(.v-text-field--single-line):not(.v-text-field--outlined).v-input--dense .v-select__slot>input{margin-top:20px}.v-autocomplete__content.v-menu__content,.v-autocomplete__content.v-menu__content .v-card{border-radius:0}\", \"\"]);\n// Exports\nmodule.exports = ___CSS_LOADER_EXPORT___;\n","// Styles\nimport './VAutocomplete.sass'\n\n// Extensions\nimport VSelect, { defaultMenuProps as VSelectMenuProps } from '../VSelect/VSelect'\nimport VTextField from '../VTextField/VTextField'\n\n// Utilities\nimport mergeData from '../../util/mergeData'\nimport {\n  getObjectValueByPath,\n  getPropertyFromItem,\n  keyCodes,\n} from '../../util/helpers'\n\n// Types\nimport { PropType, VNode } from 'vue'\nimport { PropValidator } from 'vue/types/options'\n\nconst defaultMenuProps = {\n  ...VSelectMenuProps,\n  offsetY: true,\n  offsetOverflow: true,\n  transition: false,\n}\n\n/* @vue/component */\nexport default VSelect.extend({\n  name: 'v-autocomplete',\n\n  props: {\n    allowOverflow: {\n      type: Boolean,\n      default: true,\n    },\n    autoSelectFirst: {\n      type: Boolean,\n      default: false,\n    },\n    filter: {\n      type: Function,\n      default: (item: any, queryText: string, itemText: string) => {\n        return itemText.toLocaleLowerCase().indexOf(queryText.toLocaleLowerCase()) > -1\n      },\n    } as PropValidator<(item: any, queryText: string, itemText: string) => boolean>,\n    hideNoData: Boolean,\n    menuProps: {\n      type: VSelect.options.props.menuProps.type,\n      default: () => defaultMenuProps,\n    },\n    noFilter: Boolean,\n    searchInput: {\n      type: String as PropType<string | null>,\n    },\n  },\n\n  data () {\n    return {\n      lazySearch: this.searchInput,\n    }\n  },\n\n  computed: {\n    classes (): object {\n      return {\n        ...VSelect.options.computed.classes.call(this),\n        'v-autocomplete': true,\n        'v-autocomplete--is-selecting-index': this.selectedIndex > -1,\n      }\n    },\n    computedItems (): object[] {\n      return this.filteredItems\n    },\n    selectedValues (): object[] {\n      return this.selectedItems.map(item => this.getValue(item))\n    },\n    hasDisplayedItems (): boolean {\n      return this.hideSelected\n        ? this.filteredItems.some(item => !this.hasItem(item))\n        : this.filteredItems.length > 0\n    },\n    currentRange (): number {\n      if (this.selectedItem == null) return 0\n\n      return String(this.getText(this.selectedItem)).length\n    },\n    filteredItems (): object[] {\n      if (!this.isSearching || this.noFilter || this.internalSearch == null) return this.allItems\n\n      return this.allItems.filter(item => {\n        const value = getPropertyFromItem(item, this.itemText)\n        const text = value != null ? String(value) : ''\n\n        return this.filter(item, String(this.internalSearch), text)\n      })\n    },\n    internalSearch: {\n      get (): string | null {\n        return this.lazySearch\n      },\n      set (val: any) { // TODO: this should be `string | null` but it breaks lots of other types\n        // emit update event only when the new\n        // search value is different from previous\n        if (this.lazySearch !== val) {\n          this.lazySearch = val\n          this.$emit('update:search-input', val)\n        }\n      },\n    },\n    isAnyValueAllowed (): boolean {\n      return false\n    },\n    isDirty (): boolean {\n      return this.searchIsDirty || this.selectedItems.length > 0\n    },\n    isSearching (): boolean {\n      return (\n        this.multiple &&\n        this.searchIsDirty\n      ) || (\n        this.searchIsDirty &&\n        this.internalSearch !== this.getText(this.selectedItem)\n      )\n    },\n    menuCanShow (): boolean {\n      if (!this.isFocused) return false\n\n      return this.hasDisplayedItems || !this.hideNoData\n    },\n    $_menuProps (): object {\n      const props = VSelect.options.computed.$_menuProps.call(this);\n      (props as any).contentClass = `v-autocomplete__content ${(props as any).contentClass || ''}`.trim()\n      return {\n        ...defaultMenuProps,\n        ...props,\n      }\n    },\n    searchIsDirty (): boolean {\n      return this.internalSearch != null &&\n        this.internalSearch !== ''\n    },\n    selectedItem (): any {\n      if (this.multiple) return null\n\n      return this.selectedItems.find(i => {\n        return this.valueComparator(this.getValue(i), this.getValue(this.internalValue))\n      })\n    },\n    listData () {\n      const data = VSelect.options.computed.listData.call(this) as any\n\n      data.props = {\n        ...data.props,\n        items: this.virtualizedItems,\n        noFilter: (\n          this.noFilter ||\n          !this.isSearching ||\n          !this.filteredItems.length\n        ),\n        searchInput: this.internalSearch,\n      }\n\n      return data\n    },\n  },\n\n  watch: {\n    filteredItems: 'onFilteredItemsChanged',\n    internalValue: 'setSearch',\n    isFocused (val) {\n      if (val) {\n        document.addEventListener('copy', this.onCopy)\n        this.$refs.input && this.$refs.input.select()\n      } else {\n        document.removeEventListener('copy', this.onCopy)\n        this.blur()\n        this.updateSelf()\n      }\n    },\n    isMenuActive (val) {\n      if (val || !this.hasSlot) return\n\n      this.lazySearch = null\n    },\n    items (val, oldVal) {\n      // If we are focused, the menu\n      // is not active, hide no data is enabled,\n      // and items change\n      // User is probably async loading\n      // items, try to activate the menu\n      if (\n        !(oldVal && oldVal.length) &&\n        this.hideNoData &&\n        this.isFocused &&\n        !this.isMenuActive &&\n        val.length\n      ) this.activateMenu()\n    },\n    searchInput (val: string) {\n      this.lazySearch = val\n    },\n    internalSearch: 'onInternalSearchChanged',\n    itemText: 'updateSelf',\n  },\n\n  created () {\n    this.setSearch()\n  },\n\n  destroyed () {\n    document.removeEventListener('copy', this.onCopy)\n  },\n\n  methods: {\n    onFilteredItemsChanged (val: never[], oldVal: never[]) {\n      // TODO: How is the watcher triggered\n      // for duplicate items? no idea\n      if (val === oldVal) return\n\n      if (!this.autoSelectFirst) {\n        const preSelectedItem = oldVal[this.$refs.menu.listIndex]\n\n        if (preSelectedItem) {\n          this.setMenuIndex(val.findIndex(i => i === preSelectedItem))\n        } else {\n          this.setMenuIndex(-1)\n        }\n        this.$emit('update:list-index', this.$refs.menu.listIndex)\n      }\n\n      this.$nextTick(() => {\n        if (\n          !this.internalSearch ||\n          (val.length !== 1 &&\n            !this.autoSelectFirst)\n        ) return\n\n        this.$refs.menu.getTiles()\n\n        if (this.autoSelectFirst && val.length) {\n          this.setMenuIndex(0)\n          this.$emit('update:list-index', this.$refs.menu.listIndex)\n        }\n      })\n    },\n    onInternalSearchChanged () {\n      this.updateMenuDimensions()\n    },\n    updateMenuDimensions () {\n      // Type from menuable is not making it through\n      this.isMenuActive && this.$refs.menu && this.$refs.menu.updateDimensions()\n    },\n    changeSelectedIndex (keyCode: number) {\n      // Do not allow changing of selectedIndex\n      // when search is dirty\n      if (this.searchIsDirty) return\n\n      if (this.multiple && keyCode === keyCodes.left) {\n        if (this.selectedIndex === -1) {\n          this.selectedIndex = this.selectedItems.length - 1\n        } else {\n          this.selectedIndex--\n        }\n      } else if (this.multiple && keyCode === keyCodes.right) {\n        if (this.selectedIndex >= this.selectedItems.length - 1) {\n          this.selectedIndex = -1\n        } else {\n          this.selectedIndex++\n        }\n      } else if (keyCode === keyCodes.backspace || keyCode === keyCodes.delete) {\n        this.deleteCurrentItem()\n      }\n    },\n    deleteCurrentItem () {\n      const curIndex = this.selectedIndex\n      const curItem = this.selectedItems[curIndex]\n\n      // Do nothing if input or item is disabled\n      if (\n        !this.isInteractive ||\n        this.getDisabled(curItem)\n      ) return\n\n      const lastIndex = this.selectedItems.length - 1\n\n      // Select the last item if\n      // there is no selection\n      if (\n        this.selectedIndex === -1 &&\n        lastIndex !== 0\n      ) {\n        this.selectedIndex = lastIndex\n\n        return\n      }\n\n      const length = this.selectedItems.length\n      const nextIndex = curIndex !== length - 1\n        ? curIndex\n        : curIndex - 1\n      const nextItem = this.selectedItems[nextIndex]\n\n      if (!nextItem) {\n        this.setValue(this.multiple ? [] : null)\n      } else {\n        this.selectItem(curItem)\n      }\n\n      this.selectedIndex = nextIndex\n    },\n    clearableCallback () {\n      this.internalSearch = null\n\n      VSelect.options.methods.clearableCallback.call(this)\n    },\n    genInput () {\n      const input = VTextField.options.methods.genInput.call(this)\n\n      input.data = mergeData(input.data!, {\n        attrs: {\n          'aria-activedescendant': getObjectValueByPath(this.$refs.menu, 'activeTile.id'),\n          autocomplete: getObjectValueByPath(input.data!, 'attrs.autocomplete', 'off'),\n        },\n        domProps: { value: this.internalSearch },\n      })\n\n      return input\n    },\n    genInputSlot () {\n      const slot = VSelect.options.methods.genInputSlot.call(this)\n\n      slot.data!.attrs!.role = 'combobox'\n\n      return slot\n    },\n    genSelections (): VNode | never[] {\n      return this.hasSlot || this.multiple\n        ? VSelect.options.methods.genSelections.call(this)\n        : []\n    },\n    onClick (e: MouseEvent) {\n      if (!this.isInteractive) return\n\n      this.selectedIndex > -1\n        ? (this.selectedIndex = -1)\n        : this.onFocus()\n\n      if (!this.isAppendInner(e.target)) this.activateMenu()\n    },\n    onInput (e: Event) {\n      if (\n        this.selectedIndex > -1 ||\n        !e.target\n      ) return\n\n      const target = e.target as HTMLInputElement\n      const value = target.value\n\n      // If typing and menu is not currently active\n      if (target.value) this.activateMenu()\n\n      if (!this.multiple && value === '') this.deleteCurrentItem()\n\n      this.internalSearch = value\n      this.badInput = target.validity && target.validity.badInput\n    },\n    onKeyDown (e: KeyboardEvent) {\n      const keyCode = e.keyCode\n\n      if (\n        e.ctrlKey ||\n        ![keyCodes.home, keyCodes.end].includes(keyCode)\n      ) {\n        VSelect.options.methods.onKeyDown.call(this, e)\n      }\n\n      // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n      this.changeSelectedIndex(keyCode)\n    },\n    onSpaceDown (e: KeyboardEvent) { /* noop */ },\n    onTabDown (e: KeyboardEvent) {\n      VSelect.options.methods.onTabDown.call(this, e)\n      this.updateSelf()\n    },\n    onUpDown (e: Event) {\n      // Prevent screen from scrolling\n      e.preventDefault()\n\n      // For autocomplete / combobox, cycling\n      // interfers with native up/down behavior\n      // instead activate the menu\n      this.activateMenu()\n    },\n    selectItem (item: object) {\n      VSelect.options.methods.selectItem.call(this, item)\n      this.setSearch()\n    },\n    setSelectedItems () {\n      VSelect.options.methods.setSelectedItems.call(this)\n\n      // #4273 Don't replace if searching\n      // #4403 Don't replace if focused\n      if (!this.isFocused) this.setSearch()\n    },\n    setSearch () {\n      // Wait for nextTick so selectedItem\n      // has had time to update\n      this.$nextTick(() => {\n        if (\n          !this.multiple ||\n          !this.internalSearch ||\n          !this.isMenuActive\n        ) {\n          this.internalSearch = (\n            !this.selectedItems.length ||\n            this.multiple ||\n            this.hasSlot\n          )\n            ? null\n            : this.getText(this.selectedItem)\n        }\n      })\n    },\n    updateSelf () {\n      if (\n        !this.searchIsDirty &&\n        !this.internalValue\n      ) return\n\n      if (\n        !this.multiple &&\n        !this.valueComparator(\n          this.internalSearch,\n          this.getValue(this.internalValue)\n        )\n      ) {\n        this.setSearch()\n      }\n    },\n    hasItem (item: any): boolean {\n      return this.selectedValues.indexOf(this.getValue(item)) > -1\n    },\n    onCopy (event: ClipboardEvent) {\n      if (this.selectedIndex === -1) return\n\n      const currentItem = this.selectedItems[this.selectedIndex]\n      const currentItemText = this.getText(currentItem)\n      event.clipboardData?.setData('text/plain', currentItemText)\n      event.clipboardData?.setData('text/vnd.vuetify.autocomplete.item+plain', currentItemText)\n      event.preventDefault()\n    },\n  },\n})\n","import mod from \"-!../../node_modules/babel-loader/lib/index.js??ref--2-0!../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Combobox.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/babel-loader/lib/index.js??ref--2-0!../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Combobox.vue?vue&type=script&lang=js&\"","\nexport default {\n  props: {\n    outlined: {\n      type: Boolean,\n      default: true,\n    }\n  }\n}\n","import { render, staticRenderFns } from \"./Combobox.vue?vue&type=template&id=1c6ecabf&\"\nimport script from \"./Combobox.vue?vue&type=script&lang=js&\"\nexport * from \"./Combobox.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","// Styles\nimport '../VAutocomplete/VAutocomplete.sass'\n\n// Extensions\nimport VSelect from '../VSelect/VSelect'\nimport VAutocomplete from '../VAutocomplete/VAutocomplete'\n\n// Utils\nimport { keyCodes } from '../../util/helpers'\n\n// Types\nimport { PropValidator } from 'vue/types/options'\n\n/* @vue/component */\nexport default VAutocomplete.extend({\n  name: 'v-combobox',\n\n  props: {\n    delimiters: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<string[]>,\n    returnObject: {\n      type: Boolean,\n      default: true,\n    },\n  },\n\n  data: () => ({\n    editingIndex: -1,\n  }),\n\n  computed: {\n    computedCounterValue (): number {\n      return this.multiple\n        ? this.selectedItems.length\n        : (this.internalSearch || '').toString().length\n    },\n    hasSlot (): boolean {\n      return VSelect.options.computed.hasSlot.call(this) || this.multiple\n    },\n    isAnyValueAllowed (): boolean {\n      return true\n    },\n    menuCanShow (): boolean {\n      if (!this.isFocused) return false\n\n      return this.hasDisplayedItems ||\n        (!!this.$slots['no-data'] && !this.hideNoData)\n    },\n    searchIsDirty (): boolean {\n      return this.internalSearch != null\n    },\n  },\n\n  methods: {\n    onInternalSearchChanged (val: any) {\n      if (\n        val &&\n        this.multiple &&\n        this.delimiters.length\n      ) {\n        const delimiter = this.delimiters.find(d => val.endsWith(d))\n        if (delimiter != null) {\n          this.internalSearch = val.slice(0, val.length - delimiter.length)\n          this.updateTags()\n        }\n      }\n\n      this.updateMenuDimensions()\n    },\n    genInput () {\n      const input = VAutocomplete.options.methods.genInput.call(this)\n\n      delete input.data!.attrs!.name\n      input.data!.on!.paste = this.onPaste\n\n      return input\n    },\n    genChipSelection (item: object, index: number) {\n      const chip = VSelect.options.methods.genChipSelection.call(this, item, index)\n\n      // Allow user to update an existing value\n      if (this.multiple) {\n        chip.componentOptions!.listeners! = {\n          ...chip.componentOptions!.listeners!,\n          dblclick: () => {\n            this.editingIndex = index\n            this.internalSearch = this.getText(item)\n            this.selectedIndex = -1\n          },\n        }\n      }\n\n      return chip\n    },\n    onChipInput (item: object) {\n      VSelect.options.methods.onChipInput.call(this, item)\n\n      this.editingIndex = -1\n    },\n    // Requires a manual definition\n    // to overwrite removal in v-autocomplete\n    onEnterDown (e: Event) {\n      e.preventDefault()\n      // If has menu index, let v-select-list handle\n      if (this.getMenuIndex() > -1) return\n\n      this.$nextTick(this.updateSelf)\n    },\n    onKeyDown (e: KeyboardEvent) {\n      const keyCode = e.keyCode\n\n      if (\n        e.ctrlKey ||\n        ![keyCodes.home, keyCodes.end].includes(keyCode)\n      ) {\n        VSelect.options.methods.onKeyDown.call(this, e)\n      }\n\n      // If user is at selection index of 0\n      // create a new tag\n      if (this.multiple &&\n        keyCode === keyCodes.left &&\n        this.$refs.input.selectionStart === 0\n      ) {\n        this.updateSelf()\n      } else if (keyCode === keyCodes.enter) {\n        this.onEnterDown(e)\n      }\n\n      // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n      this.changeSelectedIndex(keyCode)\n    },\n    onTabDown (e: KeyboardEvent) {\n      // When adding tags, if searching and\n      // there is not a filtered options,\n      // add the value to the tags list\n      if (this.multiple &&\n        this.internalSearch &&\n        this.getMenuIndex() === -1\n      ) {\n        e.preventDefault()\n        e.stopPropagation()\n\n        return this.updateTags()\n      }\n\n      VAutocomplete.options.methods.onTabDown.call(this, e)\n    },\n    selectItem (item: object) {\n      // Currently only supports items:<string[]>\n      if (this.editingIndex > -1) {\n        this.updateEditing()\n      } else {\n        VAutocomplete.options.methods.selectItem.call(this, item)\n\n        // if selected item contains search value,\n        // remove the search string\n        if (\n          this.internalSearch &&\n          this.multiple &&\n          this.getText(item).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase())\n        ) {\n          this.internalSearch = null\n        }\n      }\n    },\n    setSelectedItems () {\n      if (this.internalValue == null ||\n        this.internalValue === ''\n      ) {\n        this.selectedItems = []\n      } else {\n        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue]\n      }\n    },\n    setValue (value?: any) {\n      VSelect.options.methods.setValue.call(this, value === undefined ? this.internalSearch : value)\n    },\n    updateEditing () {\n      const value = this.internalValue.slice()\n      const index = this.selectedItems.findIndex(item =>\n        this.getText(item) === this.internalSearch)\n\n      // If user enters a duplicate text on chip edit,\n      // don't add it, move it to the end of the list\n      if (index > -1) {\n        const item = typeof value[index] === 'object'\n          ? Object.assign({}, value[index])\n          : value[index]\n\n        value.splice(index, 1)\n        value.push(item)\n      } else {\n        value[this.editingIndex] = this.internalSearch\n      }\n\n      this.setValue(value)\n      this.editingIndex = -1\n      this.internalSearch = null\n    },\n    updateCombobox () {\n      // If search is not dirty, do nothing\n      if (!this.searchIsDirty) return\n\n      // The internal search is not matching\n      // the internal value, update the input\n      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue()\n\n      // Reset search if using slot to avoid a double input\n      const isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips\n      if (isUsingSlot) this.internalSearch = null\n    },\n    updateSelf () {\n      this.multiple ? this.updateTags() : this.updateCombobox()\n    },\n    updateTags () {\n      const menuIndex = this.getMenuIndex()\n\n      // If the user is not searching\n      // and no menu item is selected\n      // or if the search is empty\n      // do nothing\n      if ((menuIndex < 0 && !this.searchIsDirty) ||\n          !this.internalSearch) return\n\n      if (this.editingIndex > -1) {\n        return this.updateEditing()\n      }\n\n      const index = this.selectedItems.findIndex(item =>\n        this.internalSearch === this.getText(item))\n\n      // If the duplicate item is an object,\n      // copy it, so that it can be added again later\n      const itemToSelect = index > -1 && typeof this.selectedItems[index] === 'object'\n        ? Object.assign({}, this.selectedItems[index])\n        : this.internalSearch\n\n      // If it already exists, do nothing\n      // this might need to change to bring\n      // the duplicated item to the last entered\n      if (index > -1) {\n        const internalValue = this.internalValue.slice()\n        internalValue.splice(index, 1)\n\n        this.setValue(internalValue)\n      }\n\n      // If menu index is greater than 1\n      // the selection is handled elsewhere\n      // TODO: find out where\n      if (menuIndex > -1) return (this.internalSearch = null)\n\n      this.selectItem(itemToSelect)\n\n      this.internalSearch = null\n    },\n    onPaste (event: ClipboardEvent) {\n      this.$emit('paste', event)\n      if (!this.multiple || this.searchIsDirty) return\n\n      const pastedItemText = event.clipboardData?.getData('text/vnd.vuetify.autocomplete.item+plain')\n      if (pastedItemText && this.findExistingIndex(pastedItemText as any) === -1) {\n        event.preventDefault()\n        VSelect.options.methods.selectItem.call(this, pastedItemText as any)\n      }\n    },\n    clearableCallback () {\n      this.editingIndex = -1\n\n      VAutocomplete.options.methods.clearableCallback.call(this)\n    },\n  },\n})\n"],"sourceRoot":""}