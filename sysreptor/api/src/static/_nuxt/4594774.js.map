{"version":3,"sources":["webpack:///../packages/markdown/mdext/helpers.js","webpack:///../packages/markdown/mdext/footnotes.js","webpack:///../packages/markdown/mdext/gfm.js","webpack:///../packages/markdown/mdext/rehypePlugins.js","webpack:///../packages/markdown/mdext/attrs.js","webpack:///../packages/markdown/mdext/image.js","webpack:///../packages/markdown/mdext/tables.js","webpack:///../packages/markdown/mdext/reference.js","webpack:///../packages/markdown/editor/annotatedtext.js","webpack:///../packages/markdown/mdext/templates.js","webpack:///../packages/markdown/mdext/todo.js","webpack:///../packages/markdown/mdext/codeHighlight.js","webpack:///../packages/markdown/mdext/label-end.js","webpack:///../packages/markdown/mdext/modified-commonmark.js","webpack:///../packages/markdown/index.js","webpack:///../packages/markdown/editor/micromark-utils.js"],"names":["addRemarkExtension","self","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","data","add","field","value","push","assert","bool","msg","Error","remarkFootnotes","this","_hiddenFootnoteSupport","text","codes","caret","tokenize","effects","ok","nok","code","enter","consume","exit","inlineFootnoteStart","leftSquareBracket","resolveAll","resolveAllFootnote","rightSquareBracket","hasStart","index","events","length","type","resolveTo","context","token","openIndex","undefined","group","start","Object","assign","end","note","splice","parser","constructs","insideSpan","null","slice","footnoteSyntax","inlineFootnote","children","unsafe","character","inConstruct","handlers","footnote","node","_","subexit","containerPhrasing","before","after","remarkToRehypeHandlersFootnotes","h","all","footnoteDefinition","footnoteReference","rehypeFootnoteSeparator","tree","visit","parent","tagName","class","rehypeFootnoteSeparatorPreview","properties","dataFootnoteRef","nextSibling","remarkStrikethrough","gfmStrikethrough","gfmStrikethroughFromMarkdown","gfmStrikethroughToMarkdown","remarkTaskListItem","gfmTaskListItem","gfmTaskListItemFromMarkdown","gfmTaskListItemToMarkdown","rehypeLinkTargetBlank","href","startsWith","target","rel","rehypeConvertAttrsToStyle","convertAttrs","entries","attrName","styleName","style","addClass","className","Array","isArray","rehypeRewriteImageSources","rewriteImageSource","src","rehypeRewriteFileLinks","rewriteFileUrl","download","rehypeTemplates","content","rehypeRawFixSelfClosingTags","console","log","replaceAll","attrsFromMarkdown","transforms","prevNode","hProperties","attrs","includes","attrsString","textAttributes","setData","buffer","cleaned","getData","attribute","resume","stack","sliceSerialize","textAttributeClassValue","parseEntities","textAttributeIdValue","textAttributeName","textAttributeValue","list","remarkToRehypeAttrs","attributes","remarkAttrs","name","leftCurlyBrace","factoryAttributes","map","k","v","split","c","join","remarkFigure","image","title","url","alt","label","fragment","peek","safeOptions","quote","checkQuote","suffix","tracker","track","move","current","test","safe","figureToMarkdown","remarkToRehypeHandlersFigure","normalizeUri","remarkTables","gfmTable","gfmTableFromMarkdown","gfmTableToMarkdown","remarkTableCaptions","captionBlock","captionText","captionPrefixLength","captionVal","captionValTrimmed","trimStart","position","column","offset","tableCaption","remarkToRehypeHandlersTableCaptions","rehypeTableCaptions","tableNode1","tableNode2","rehypeReferenceLink","to","substring","rehypeReferenceLinkPreview","rewriteReferenceLink","refNodes","refTargets","id","refId","refPreview","some","cn","createBlockSeparator","pos","micromarkToAnnotatedText","micromarkEventsToTree","i","leafNodes","interpretAsLeafNodes","interpretAsLeafNodesFns","wrapTypesWithBlockSeparators","collectLeafNodes","t","n","wrapWithSeparators","extractLeafNodesFromMicromarkTree","textTypes","markupTypesInterpretAs","annotatedText","markup","interpretAs","annotatedTextParse","Parser","parseMicromarkEvents","extensions","remarkTemplateVariables","closeBraceCount","start2","between","eof","rightCurlyBrace","sequenceClose","templateVariable","remarkTodoMarker","uppercaseT","tokenizeTodo","lowercaseT","middleO","uppercaseO","lowercaseO","middleDorDash","dash","middleD","uppercaseD","lowercaseD","endO","todoSyntax","todo","hName","splitTreeAtPosition","splitPos","processChildren","flat","currentPos","childrenLeft","childrenRight","processNode","pc","toString","nodeLength","wrapTreeAreas","wrapInfos","wi","startMarkerPos","endMarkerPos","ci","wii","concat","markerTree","rehypeHighlightCode","meta","metaLine","fromEntries","from","matchAll","m","camelCase","groups","highlightManual","lineNumbers","Number","parseInt","parseMeta","highlightInfos","highlightMarkerRe","highlightedAreaRe","RegExp","parts","codeNew","highlightInfo","startMarker","endMarker","parseManualHighlightAreas","language","filter","toLowerCase","getLanguage","lowlight","highlight","error","highlightSyntax","hi","unified","use","rehypeParse","parse","applyManualHighlighting","lines","line","dataLineNumber","splitIntoLines","labelEnd","labelStart","defined","types","labelImage","labelLink","_labelEnd_balanced","_inactive","balanced","normalizeIdentifier","now","labelMarker","afterLabelEnd","leftParenthesis","attempt","resourceConstruct","fullReferenceConstruct","collapsedReferenceConstruct","open","close","media","link","labelText","resource","resourceMarker","factoryWhitespace","rightParenthesis","factoryDestination","destinationAfter","resourceDestination","resourceDestinationLiteral","resourceDestinationLiteralMarker","resourceDestinationRaw","resourceDestinationString","constants","linkResourceDestinationBalanceMax","markdownLineEndingOrSpace","quotationMark","apostrophe","factoryTitle","resourceTitle","resourceTitleMarker","resourceTitleString","factoryLabel","call","afterLabel","reference","referenceMarker","referenceString","labelEndSyntax","modifiedCommonmarkFeatures","disable","rehypeSanitizeSchema","merge","defaultSchema","allowComments","clobberPrefix","tagNames","markdownParser","renderMarkdownToHtml","preview","rewriteFileSource","md","remarkParse","remarkRehype","allowDangerousHtml","footnoteLabelTagName","rehypeRaw","rehypeSanitize","rehypeStringify","mdHtml","processSync","markdownToAnnotatedText","config","postprocess","document","write","preprocess","action","treeNode"],"mappings":"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","file":"4594774.js","sourcesContent":["export function addRemarkExtension(self, micromarkExtensions, fromMarkdownExtensions, toMarkdownExtensions) {\n  const data = self.data();\n\n  add('micromarkExtensions', micromarkExtensions);\n  add('fromMarkdownExtensions', fromMarkdownExtensions);\n  add('toMarkdownExtensions', toMarkdownExtensions);\n\n  /**\n  * @param {string} field\n  * @param {unknown} value\n  */\n  function add(field, value) {\n    if (!value) {\n      return;\n    }\n\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n\n\nexport function assert(bool, msg) {\n  if (!bool) {\n    throw new Error(msg);\n  }\n}","import {splice} from 'micromark-util-chunked'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {all} from 'remark-rehype';\nimport {visit} from 'unist-util-visit';\nimport { addRemarkExtension, assert } from './helpers';\nimport {h} from 'hastscript';\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * \n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n \n\n/**\n * @returns {Extension}\n */\nfunction footnoteSyntax() {\n  /** @type {Extension} */\n  return {\n    _hiddenFootnoteSupport: {},\n    text: {\n      [codes.caret]: {\n        tokenize: tokenizeInlineFootnoteStart, \n        resolveAll: resolveAllFootnote\n      },\n      [codes.rightSquareBracket]: {\n        add: 'after',\n        tokenize: tokenizeInlineFootnoteEnd,\n        resolveAll: resolveAllFootnote,\n        resolveTo: resolveToFootnoteEnd\n      },  \n    }\n  };\n\n  /** @type {Tokenizer} */\n  function tokenizeInlineFootnoteStart(effects, ok, nok) {\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.caret, 'expected `^`');\n      effects.enter('inlineFootnoteStart');\n      effects.enter('inlineFootnoteMarker');\n      effects.consume(code);\n      effects.exit('inlineFootnoteMarker');\n      return inlineFootnoteStart;\n    }\n\n    /** @type {State} */\n    function inlineFootnoteStart(code) {\n      if (code !== codes.leftSquareBracket) {\n        return nok(code);\n      }\n\n      effects.enter('inlineFootnoteStartMarker');\n      effects.consume(code);\n      effects.exit('inlineFootnoteStartMarker');\n      effects.exit('inlineFootnoteStart');\n      return ok;\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeInlineFootnoteEnd(effects, ok, nok) {\n    const self = this;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.rightSquareBracket, 'expected `]`');\n      let index = self.events.length;\n      /** @type {boolean|undefined} */\n      let hasStart;\n\n      // Find an opening.\n      while (index--) {\n        if (self.events[index][1].type === 'inlineFootnoteStart') {\n          hasStart = true;\n          break;\n        }\n      }\n\n      if (!hasStart) {\n        return nok(code);\n      }\n\n      effects.enter('inlineFootnoteEnd');\n      effects.enter('inlineFootnoteEndMarker');\n      effects.consume(code);\n      effects.exit('inlineFootnoteEndMarker');\n      effects.exit('inlineFootnoteEnd');\n      return ok;\n    }\n  }\n\n  /**\n   * Remove remaining note starts.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllFootnote(events) {\n    let index = -1;\n    /** @type {Token} */\n    let token;\n\n    while (++index < events.length) {\n      token = events[index][1];\n\n      if (events[index][0] === 'enter' && token.type === 'inlineFootnoteStart') {\n        token.type = 'data';\n        // Remove the two marker (`^[`).\n        events.splice(index + 1, 4);\n      }\n    }\n\n    return events;\n  }\n\n  /** @type {Resolver} */\n  function resolveToFootnoteEnd(events, context) {\n    let index = events.length - 4;\n    /** @type {Token} */\n    let token;\n    /** @type {number} */\n    let openIndex;\n\n    // Find an opening.\n    while (index--) {\n      token = events[index][1];\n\n      // Find where the note starts.\n      if (events[index][0] === 'enter' && token.type === 'inlineFootnoteStart') {\n        openIndex = index;\n        break;\n      }\n    }\n\n    // @ts-expect-error It’s fine.\n    assert(openIndex !== undefined, 'expected `openIndex` to be found');\n\n    /** @type {Token} */\n    const group = {\n      type: 'inlineFootnote',\n      start: Object.assign({}, events[openIndex][1].start),\n      end: Object.assign({}, events[events.length - 1][1].end),\n    }\n\n    const text = {\n      type: 'inlineFootnoteText',\n      start: Object.assign({}, events[openIndex + 4][1].end),\n      end: Object.assign({}, events[events.length - 3][1].start),\n    }\n\n    const note = [\n      ['enter', group, context],\n      events[openIndex + 1],\n      events[openIndex + 2],\n      events[openIndex + 3],\n      events[openIndex + 4],\n      ['enter', text, context]\n    ];\n\n    splice(\n      note,\n      note.length,\n      0,\n      resolveAll(\n        context.parser.constructs.insideSpan.null,\n        events.slice(openIndex + 6, -4),\n        context\n      )\n    );\n\n    note.push(\n      ['exit', text, context],\n      events[events.length - 3],\n      events[events.length - 2],\n      ['exit', group, context]\n    );\n\n    splice(events, index, events.length - index, note);\n\n    return events;\n  }\n}\n\n\n\nfunction footnoteFromMarkdown() {\n  /** @type {FromMarkdownExtension} */\n  return {\n    enter: {\n      inlineFootnote: enterInlineFootnote,\n    },\n    exit: {\n      inlineFootnote: exitInlineFootnote,\n    }\n  };\n\n  function enterInlineFootnote(token) {\n    this.enter({type: 'footnote', children: []}, token);\n  }\n\n  function exitInlineFootnote(token) {\n    this.exit(token);\n  }\n}\n\nfunction footnoteToMarkdown() {\n  return {\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnote},\n  };\n\n  function footnote(node, _, context) {\n    const exit = context.enter('footnote');\n    const subexit = context.enter('label');\n    const value = '^[' + containerPhrasing(node, context, {before: '[', after: ']'}) + ']';\n    subexit();\n    exit();\n    return value;\n  }\n};\n\n\n\nexport function remarkFootnotes() {\n  addRemarkExtension(this, footnoteSyntax(), footnoteFromMarkdown(), footnoteToMarkdown());\n}\n\n\n/**\n * Render footnotes as <footnote>content</footnote>\n */\nexport const remarkToRehypeHandlersFootnotes = {\n  footnote(h, node) {\n    return h(node, 'footnote', all(h, node))\n  },\n  footnoteDefinition(h, node) {\n    return null;\n  },\n  footnoteReference(h, node) {\n    return null;\n  },\n};\n\n\nexport function rehypeFootnoteSeparator() {\n  // add a footnote call separator tag between consecutive <footnote> tags\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    if (node.tagName === 'footnote' && parent.children[index + 1]?.tagName === 'footnote') {\n      parent.children.splice(index + 1, 0, h('sup', {class: 'footnote-call-separator'}));\n    }\n  })\n}\n\n\nexport function rehypeFootnoteSeparatorPreview() {\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    // Remove link from footnote call\n    if (node.tagName !== 'sup' || node.children.length !== 1 || !node.children[0]?.properties?.dataFootnoteRef) {\n      return;\n    }\n    node.children = node.children[0].children;\n\n    // Add footnote call separator\n    const nextSibling = parent.children[index + 1];\n    if (nextSibling?.tagName !== 'sup' || nextSibling.children.length !== 1 || !nextSibling.children[0]?.properties?.dataFootnoteRef) {\n      return;\n    }\n    parent.children.splice(index + 1, 0, h('sup', {class: 'footnote-call-separator'}, [',']));\n  })\n}","import { gfmStrikethrough } from 'micromark-extension-gfm-strikethrough';\nimport { gfmStrikethroughFromMarkdown, gfmStrikethroughToMarkdown } from 'mdast-util-gfm-strikethrough';\nimport { gfmTaskListItem } from 'micromark-extension-gfm-task-list-item';\nimport { gfmTaskListItemFromMarkdown, gfmTaskListItemToMarkdown } from 'mdast-util-gfm-task-list-item';\nimport { addRemarkExtension } from './helpers';\n\n\nexport function remarkStrikethrough() {\n  addRemarkExtension(this, gfmStrikethrough(), gfmStrikethroughFromMarkdown, gfmStrikethroughToMarkdown);\n}\n\n\nexport function remarkTaskListItem() {\n  addRemarkExtension(this, gfmTaskListItem, gfmTaskListItemFromMarkdown, gfmTaskListItemToMarkdown);\n}\n","import {visit} from 'unist-util-visit';\n\n/**\n * Add target=\"_blank\" to links.\n */\nexport function rehypeLinkTargetBlank() {\n  return tree => {\n    visit(tree, 'element', node => {\n      if (node.tagName === 'a' && !(node.properties.href || '#').startsWith('#')) {\n        node.properties.target = '_blank';\n        node.properties.rel = 'nofollow noopener noreferrer';\n      }\n    });\n  }\n}\n\n/**\n * Convert HTML attributes to inline CSS styles.\n */\nexport function rehypeConvertAttrsToStyle() {\n  const convertAttrs = {\n    'width': 'width', \n    'height': 'height'\n  };\n\n  return tree => {\n    visit(tree, 'element', node => {\n      for (const [attrName, styleName] of Object.entries(convertAttrs)) {\n        if (node.properties[attrName]) {\n          let style = (node.properties.style || '');\n          if (style && style[style.length - 1] !== ';') {\n            style += ';'\n          }\n          style += styleName + ':' + node.properties[attrName] + ';';\n          node.properties.style = style;\n          node.properties[attrName] = undefined;\n        }\n      }\n    });\n  }\n}\n\n\nexport function addClass(node, className) {\n  if (!node.properties.className) {\n    node.properties.className = [];\n  }  \n  if (Array.isArray(className)) {\n    node.properties.className.push(...className);\n  } else {\n    node.properties.className.push(className);\n  }\n}\n\n\nexport function rehypeRewriteImageSources({rewriteImageSource}) {\n  return tree => visit(tree, 'element', node => {\n    if (node.tagName === 'img' && node.properties.src && rewriteImageSource) {\n      node.properties.src = rewriteImageSource(node.properties.src);\n    }\n  });\n}\n\n\nexport function rehypeRewriteFileLinks({ rewriteFileUrl }) {\n  return tree => visit(tree, 'element', node => {\n    if (node.tagName === 'a' && node.properties?.href?.startsWith('/files/') && rewriteFileUrl) {\n      node.properties.href = rewriteFileUrl(node.properties.href);\n      node.properties.download = true;\n      addClass(node, ['file-download-preview', 'v-icon', 'mdi', 'mdi-file-download']);\n    }\n  });\n}\n\n\nexport function rehypeTemplates() {\n  return tree => visit(tree, 'element', node => {\n    if (node.tagName === 'template') {\n      node.children = node.content?.children || [];\n      node.tagName = 'span';\n    }\n  })\n}\n\n\n/**\n * Replace self-closing tags with a combination of start and end tag.\n */\nexport function rehypeRawFixSelfClosingTags() {\n  return tree => visit(tree, 'raw', (node) => {\n    console.log(node.value);\n    node.value = node.value.replaceAll(/<(?<tag>[a-zA-Z0-9-]+)(?<attrs>[^>]*)\\/>/g, \"<$<tag>$<attrs>></$<tag>>\");\n    console.log(node.value);\n  });\n}","import {codes} from 'micromark-util-symbol/codes.js';\nimport {factoryAttributes} from 'micromark-extension-directive/lib/factory-attributes.js';\nimport {parseEntities} from 'parse-entities';\nimport {visit} from 'unist-util-visit';\nimport { addRemarkExtension } from './helpers';\n\n\nfunction attrsSyntax() {\n  return {\n    name: 'attrs',\n    text: {\n      [codes.leftCurlyBrace]: {\n        tokenize: tokenizeAttributes,\n      }\n    }\n  };\n\n  function tokenizeAttributes(effects, ok, nok) {\n    // Always a `{`\n    return factoryAttributes(\n      effects,\n      ok,\n      nok,\n      'textAttributes',\n      'textAttributesMarker',\n      'textAttribute',\n      'textAttributeId',\n      'textAttributeClass',\n      'textAttributeName',\n      'textAttributeInitializerMarker',\n      'textAttributeValueLiteral',\n      'textAttributeValue',\n      'textAttributeValueMarker',\n      'textAttributeValueData'\n    )\n  }\n};\n\n\nfunction attrsFromMarkdown() {\n  return {\n    transforms: [transformAttributesAttachToElements],\n    enter: {\n      textAttributes: enterAttributes,\n    },\n    exit: {\n      textAttributes: exitAttributes,\n      textAttributeClassValue: exitAttributeClassValue,\n      textAttributeIdValue: exitAttributeIdValue,\n      textAttributeName: exitAttributeName,\n      textAttributeValue: exitAttributeValue,\n    }\n  };\n\n  function enterAttributes(token) {\n    this.setData('directiveAttributes', []);\n    this.enter({type: 'attributes', attrs: {}, attrsString: ''}, token);\n    this.buffer();\n  }\n\n  function exitAttributeIdValue(token) {\n    const list = this.getData('directiveAttributes');\n    list.push(['id', parseEntities(this.sliceSerialize(token))])\n  }\n\n  function exitAttributeClassValue(token) {\n    const list = this.getData('directiveAttributes');\n    list.push(['class', parseEntities(this.sliceSerialize(token))])\n  }\n\n  function exitAttributeValue(token) {\n    const list = this.getData('directiveAttributes');\n    list[list.length - 1][1] = parseEntities(this.sliceSerialize(token))\n  }\n\n  function exitAttributeName(token) {\n    // Attribute names in CommonMark are significantly limited, so character\n    // references can’t exist.\n    this.getData('directiveAttributes').push([this.sliceSerialize(token), ''])\n  }\n\n  function exitAttributes(token) {\n    const cleaned = {};\n    for (const attribute of this.getData('directiveAttributes')) {\n      if (attribute[0] === 'class' && cleaned.class) {\n        cleaned.class += ' ' + attribute[1];\n      } else {\n        cleaned[attribute[0]] = attribute[1];\n      }\n    }\n  \n    this.setData('directiveAttributes')\n    this.resume(); // Drop EOLs\n\n    const node = this.stack[this.stack.length - 1];\n    node.attrs = cleaned;\n    node.attrsString = this.sliceSerialize(token);\n    this.exit(token);\n  }\n\n  function transformAttributesAttachToElements(tree) {\n    // Attach attributes to elements or convert to text\n    visit(tree, (node, index, parent) => {\n      if (node.type === 'attributes') {\n        const prevNode = index > 0 ? parent.children[index - 1] : null;\n        if (prevNode && prevNode.type !== 'text') {\n          // Attach attributes to previous element e.g. ![img](img.png){width=\"50%\"}, **bold**{.styled}, but not \"**bold** {.not-styled}\"\n          prevNode.data = {...prevNode.data, hProperties: node.attrs};\n        } else if (['heading', 'tableCaption'].includes(parent.type)) {\n          // Attach attributes to parent element e.g. \"# Heading {#chapter-id}\"\n          parent.data = {...parent.data, hProperties: node.attrs};\n        } else {\n          // Could not attach to any node: convert attributes to text\n          node.type = 'text';\n          node.value = node.attrsString;\n          delete node.attrs;\n          delete node.attrsString;\n        }\n      }\n    });\n  }\n}\n\n\nfunction attrsToMarkdown() {\n  return {\n    handlers: {\n      attributes\n    }\n  };\n\n  function attributes(node, _, context) {\n    const exit = context.enter('attributes');\n    const value = node.attrsString || Object.entries(node.attrs).map(([k, v]) => {\n      if (k === 'id') { return '#' + v }\n      else if (k === 'class') { return v.split(' ').map(c => '.' + c).join(' ')}\n      else { return `${k}=${v}`; }\n    }).join(' ');\n    exit();\n    return value;\n  }\n}\n\nexport const remarkToRehypeAttrs = {\n  attributes(h, node) {\n    // Remove attributes nodes\n    return null;\n  }\n}\n\nexport function remarkAttrs() {\n  addRemarkExtension(this, attrsSyntax(), attrsFromMarkdown(), attrsToMarkdown());\n}\n\n","import { addRemarkExtension } from \"./helpers\";\nimport {checkQuote} from 'mdast-util-to-markdown/lib/util/check-quote.js'\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {all} from 'remark-rehype';\nimport {normalizeUri} from 'micromark-util-sanitize-uri';\n\n\nfunction figureFromMarkdown() {\n  // Extend default image formatter from mdast-util-from-markdown to support child markdown text\n  return {\n    enter: {\n      image: enterImage,\n    }, \n    exit: {\n      label: exitLabel,\n    }\n  };\n\n  function enterImage(token) {\n    this.enter({type: 'image', title: null, url: '', alt: null, children: []}, token);\n  }\n\n\n  /**\n   * Label for link or image\n   */\n  function exitLabel(token) {\n    const fragment = /** @type {Fragment} */ (this.stack[this.stack.length - 1]);\n    const value = this.resume();\n    const node =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */ (\n        this.stack[this.stack.length - 1]\n      );\n\n    // Assume a reference.\n    this.setData('inReference', true);\n\n    // @ts-expect-error: Assume static phrasing content.\n    node.children = fragment.children;\n    if (node.type === 'image') {\n      node.alt = value;\n    }\n  }\n}\n\n\nfunction figureToMarkdown() {\n  image.peek = () => '!';\n\n  return {\n    handlers: {\n      image\n    },\n  };\n\n  function image(node, _, context, safeOptions) {\n    const quote = checkQuote(context);\n    const suffix = quote === '\"' ? 'Quote' : 'Apostrophe';\n    const exit = context.enter('image');\n    let subexit = context.enter('label');\n    const tracker = track(safeOptions);\n    let value = tracker.move('![');\n    value += tracker.move(\n      containerPhrasing(node, context, {\n        before: value,\n        after: '](',\n        ...tracker.current()\n      })\n    );\n    value += tracker.move('](');\n\n    subexit();\n\n    if (\n      // If there’s no url but there is a title…\n      (!node.url && node.title) ||\n      // If there are control characters or whitespace.\n      /[\\0- \\u007F]/.test(node.url)\n    ) {\n      subexit = context.enter('destinationLiteral');\n      value += tracker.move('<');\n      value += tracker.move(\n        safe(context, node.url, {before: value, after: '>', ...tracker.current()})\n      );\n      value += tracker.move('>');\n    } else {\n      // No whitespace, raw is prettier.\n      subexit = context.enter('destinationRaw');\n      value += tracker.move(\n        safe(context, node.url, {\n          before: value,\n          after: node.title ? ' ' : ')',\n          ...tracker.current()\n        })\n      );\n    }\n\n    subexit();\n\n    if (node.title) {\n      subexit = context.enter('title' + suffix);\n      value += tracker.move(' ' + quote);\n      value += tracker.move(\n        safe(context, node.title, {\n          before: value,\n          after: quote,\n          ...tracker.current()\n        })\n      );\n      value += tracker.move(quote);\n      subexit();\n    }\n\n    value += tracker.move(')');\n    exit();\n\n    return value;\n  }\n  \n}\n\n\nexport function remarkFigure() {\n  addRemarkExtension(this, {}, figureFromMarkdown(), figureToMarkdown());\n}\n\n\nexport const remarkToRehypeHandlersFigure = {\n  image(h, node) {\n    // only add attributes to <img> tag, not to <figure>\n    const attrs = (node.data || {}).hProperties || {};\n    if (!node.data) {\n      node.data = {};\n    }\n    node.data.hProperties = {};\n\n    return h(node, 'figure', [\n      h(node, 'img', {src: normalizeUri(node.url), alt: node.alt, ...attrs}),\n      ...(node.children.length > 0 ? [h(node, 'figcaption', all(h, node))] : [])\n    ]);\n  }\n};\n","import { gfmTable } from 'micromark-extension-gfm-table';\nimport { gfmTableFromMarkdown, gfmTableToMarkdown } from 'mdast-util-gfm-table';\nimport { addRemarkExtension } from './helpers';\nimport { visit } from 'unist-util-visit';\nimport { all } from 'remark-rehype';\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\n\n\nexport function remarkTables() {\n  addRemarkExtension(this, gfmTable, gfmTableFromMarkdown, gfmTableToMarkdown());\n}\n\n\nfunction tableCaptionFromMarkdown() {\n  return {\n    transforms: [transformTableCaption]\n  };\n\n  function transformTableCaption(tree) {\n    visit(tree, (node, index, parent) => {\n      if (node.type === 'table') {\n        const captionBlock = parent.children[index + 1];\n        if (captionBlock && captionBlock.type === 'paragraph' && captionBlock.children.length > 0 && captionBlock.children[0].type === 'text') {\n          const captionText = captionBlock.children[0];\n          let captionPrefixLength = 0;\n          if (captionText.value.startsWith(':')) {\n            captionPrefixLength = 1;\n          } else if (captionText.value.startsWith('Table:')) {\n            captionPrefixLength = 6;\n          }\n\n          \n          if (captionPrefixLength) {\n            const captionVal = captionText.value.slice(captionPrefixLength);\n            const captionValTrimmed = captionVal.trimStart();\n            captionPrefixLength += captionVal.length - captionValTrimmed.length;\n\n            captionText.value = captionText.value.slice(captionPrefixLength);\n            captionText.position.start.column += captionPrefixLength;\n            captionText.position.start.offset += captionPrefixLength;\n\n            // Mark block as table caption, but do not move caption into table (this is done when transforming to rehype)\n            captionBlock.type = 'tableCaption';\n          }\n        }\n      }\n    });\n  }\n}\n\n\nfunction tableCaptionToMarkdown() {\n  return {\n    handlers: {tableCaption},\n  };\n\n  function tableCaption(node, _, context, safeOptions) {\n    const exit = context.enter('tableCaption');\n    const subexit = context.enter('phrasing');\n    const value = 'Table: ' + containerPhrasing(node, context, safeOptions);\n    subexit();\n    exit();\n    return value;\n  }\n}\n\n\nexport function remarkTableCaptions() {\n  addRemarkExtension(this, {}, tableCaptionFromMarkdown(), tableCaptionToMarkdown());\n}\n\n\nexport const remarkToRehypeHandlersTableCaptions = {\n  tableCaption(h, node) {\n    return h(node, 'caption', all(h, node));\n  }\n};\n\nexport function rehypeTableCaptions() {\n  return tree =>\n    visit(tree, 'element', (node, index, parent) => {\n      if (node.tagName === 'caption') {\n        // Move table caption tag into HTML table\n        const tableNode1 = parent.children[index - 1];\n        const tableNode2 = parent.children[index - 2];\n        if (tableNode1 && tableNode1.tagName === 'table') {\n          tableNode1.children.push(node);\n          parent.children.splice(index, 1);\n        } else if (tableNode1 && tableNode1.type === 'text' && tableNode1.value === '\\n' && tableNode2.tagName === 'table') {\n          tableNode2.children.push(node);\n          parent.children.splice(index, 1);\n        }\n      }\n    });\n}","import { visit } from 'unist-util-visit';\nimport { addClass } from './rehypePlugins';\n\n\nexport function rehypeReferenceLink() {\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    if (node.tagName === 'a' && node.properties.href && node.properties.href.startsWith('#')) {\n      node.tagName = 'ref';\n      node.properties.to = node.properties.href.substring(1);\n      delete node.properties.href;\n    }\n  });\n}\n\n\nexport function rehypeReferenceLinkPreview({ rewriteReferenceLink = null }) {\n  return tree => {\n    let refNodes = [];\n    let refTargets = {};\n\n    // Collect references and elements that can be references\n    visit(tree, 'element', (node, index, parent) => {\n      if (node.tagName === 'a' && node.properties.href && node.properties.href.startsWith('#')) {\n        refNodes.push(node);\n      }\n      if (node.properties.id) {\n        refTargets[node.properties.id] = {node, index, parent};\n      }\n    });\n\n    // Resolve references\n    if (refNodes.length > 0) {\n      for (const node of refNodes) {\n        const refId = node.properties.href.substring(1);\n\n        let refPreview = null;\n        // Known reference target (e.g. other finding)\n        if (!refPreview && rewriteReferenceLink) {\n          refPreview = rewriteReferenceLink(refId);\n        }\n\n        // Local reference target (e.g. figure in same markdown field)\n        if (!refPreview && refTargets[refId]) {\n          if (refTargets[refId].node.tagName === 'img' && \n              refTargets[refId].parent.tagName === 'figure' && \n              refTargets[refId].parent.children.some(cn => cn.tagName === 'figcaption')) {\n            refPreview = {\n              title: `[Figure #${refId}]`,\n            };\n          }\n          if (refTargets[refId].node.tagName === 'caption') {\n            refPreview = {\n              title: `[Table #${refId}]`,\n            };\n          }\n        }\n\n        // Unknown reference target\n        if (!refPreview) {\n          refPreview = {\n            title: `[Reference to #${refId}]`,\n          };\n        }\n\n        // Update reference node\n        addClass(node, 'ref');\n        if (refPreview.href) {\n          node.properties.href = refPreview.href;\n        }\n        if (refPreview.title && node.children.length === 0) {\n          node.children.push({type: 'text', value: refPreview.title});\n        }\n      }\n    }\n\n  }\n}\n\n","import { micromarkEventsToTree, parseMicromarkEvents } from './micromark-utils.js';\n\n\nfunction createBlockSeparator(pos) {\n  return {\n    type: 'annotatedTextBlockSeparator', \n    text: '', \n    children: [],\n    enter: {\n      type: 'annotatedTextBlockSeparator',\n      start: pos,\n      end: pos,\n    },\n    exit: {\n      type: 'annotatedTextBlockSeparator',\n      start: pos,\n      end: pos,\n    },\n  };\n}\n\nexport function extractLeafNodesFromMicromarkTree(tree, {interpretAsLeafNodes = [], interpretAsLeafNodesFns = {}, wrapTypesWithBlockSeparators = []}) {\n  const leafNodes = [];\n  collectLeafNodes(tree);\n  return leafNodes;\n\n  function collectLeafNodes(t) {\n    for (const n of t) {\n      const wrapWithSeparators = wrapTypesWithBlockSeparators.includes(n.type);\n      if (wrapWithSeparators) {\n        leafNodes.push(createBlockSeparator(n.enter.start));\n      }\n\n      if (n.children.length === 0 || interpretAsLeafNodes.includes(n.type) || interpretAsLeafNodesFns[n.type]?.(n)) {\n        leafNodes.push(n);\n      } else {\n        collectLeafNodes(n.children);\n      }\n\n      if (wrapWithSeparators) {\n        leafNodes.push(createBlockSeparator(n.exit.end));\n      }\n    }\n  } \n}\n\n\n\nfunction micromarkToAnnotatedText(text, events) {\n  const tree = micromarkEventsToTree(text, events);\n  // console.log('micromark tree', tree);\n\n  // Add separators between blocks, such that blocks are always interpreted as separate\n  for (let i = tree.length - 1; i >= 0; i--) {\n    tree.splice(i, 0, createBlockSeparator(tree[i].enter.start));\n  }\n\n  // extract leaf nodes of tree => this is a sequence of all the text tokens\n  const leafNodes = extractLeafNodesFromMicromarkTree(tree, {\n    interpretAsLeafNodes: ['codeFenced', 'codeText', 'textAttributes', 'inlineFootnote', 'table', 'resource', 'templateVariable'],\n    interpretAsLeafNodesFns: {\n      'labelText': n => n.children.length === 0,\n    },\n    wrapTypesWithBlockSeparators: ['image'],\n  });\n\n  // console.log('annotatedText.leafNodes', leafNodes)\n\n  // convert leaf nodes to annotatedText => either text or markup\n  // TODO: support table caption in micromark (instead of mdast)\n  const textTypes = ['data', 'lineEnding', 'lineEndingBlank'];\n  const markupTypesInterpretAs = {\n    'listItemMarker': '\\n\\n',\n    'codeFenced': '\\n\\n',\n    'annotatedTextBlockSeparator': '\\n\\n',\n    'codeText': '`code`',\n    'templateVariable': '`code`',\n    'labelText': '`code`',\n    'htmlTextData': '`code`',\n  };\n  const annotatedText = [];\n  for (const n of leafNodes) {\n    if (n.type === 'lineEnding') {\n      // Workaround for micromark bug: the end position of lineEnding elements is wrong (overlaps with next element)\n      annotatedText.push({\n        text: '\\n',\n        offset: n.enter.start.offset,\n      });\n    } else if (textTypes.includes(n.type)) {\n      annotatedText.push({\n        text: n.text,\n        offset: n.enter.start.offset,\n      });\n    } else {\n      annotatedText.push({\n        markup: n.text,\n        offset: n.enter.start.offset,\n        interpretAs: markupTypesInterpretAs[n.type] || '',\n      });\n    }\n  }\n  return annotatedText;\n}\n\n\nexport function annotatedTextParse() {\n  const micromarkExtensions = this.data('micromarkExtensions') || [];\n  this.Parser = parser;\n\n  function parser(text) {\n    const events = parseMicromarkEvents(text, {extensions: micromarkExtensions});\n    return micromarkToAnnotatedText(text, events);\n  }\n}","import { codes } from 'micromark-util-symbol/codes.js';\nimport { addRemarkExtension, assert } from './helpers';\n\n\nfunction templateVariableSyntax() {\n  return {\n    text: {\n      [codes.leftCurlyBrace]: {\n        tokenize: tokenizeTemplateVariable,\n      },\n    }\n  };\n\n  function tokenizeTemplateVariable(effects, ok, nok) {\n    let closeBraceCount = 0;\n    return start;\n\n    function start(code) {\n      assert(code === codes.leftCurlyBrace, 'expected `{`}');\n      effects.enter('templateVariable');\n      effects.consume(code);\n      return start2;\n    }\n    function start2(code) {\n      if (code !== codes.leftCurlyBrace) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return between;\n    }\n    function between(code) {\n      if (code === codes.eof) {\n        return nok(code);\n      } else if (code === codes.rightCurlyBrace) {\n        // Closing sequence or part of content?\n        closeBraceCount = 0;\n        return sequenceClose(code);\n      } else {\n        effects.consume(code);\n        return between;\n      }\n    }\n    function sequenceClose(code) {\n      if (code === codes.rightCurlyBrace) {\n        effects.consume(code);\n        closeBraceCount += 1;\n\n        if (closeBraceCount === 2) {\n          // Dummy close events, rewritten in resolveTemplateVariable\n          effects.exit('templateVariable');\n          return ok(code);\n        } else {\n          return sequenceClose;\n        }\n      } else {\n        return between(code);\n      }\n    }\n  }\n\n}\n\n\nfunction templateVariableFromMarkdown() {\n  return {\n    enter: {\n      templateVariable: enterTemplateVariable,\n    },\n    exit: {\n      templateVariable: exitTemplateVariable,\n    }\n  };\n\n  function enterTemplateVariable(token) {\n    this.enter({type: 'templateVariable', value: ''}, token);\n  }\n  function exitTemplateVariable(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.value = this.sliceSerialize(token); \n    this.exit(token);\n  }\n}\n\nfunction templateVariableToMarkdown() {\n  return {\n    handlers: {\n      templateVariable,\n    } \n  };\n\n  function templateVariable(node, _, context) {\n    const exit = context.enter('templateVariable');\n    const value = node.value;\n    exit();\n    return value;\n  }\n}\n\n\nexport function remarkTemplateVariables() {\n  addRemarkExtension(this, templateVariableSyntax(), templateVariableFromMarkdown(), templateVariableToMarkdown());\n}\n","import { codes } from 'micromark-util-symbol/codes.js';\nimport { addRemarkExtension } from \"./helpers\";\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\n\n\nfunction todoSyntax() {\n  return {\n    name: 'todo',\n    text: {\n      [codes.uppercaseT]: {\n        tokenize: tokenizeTodo,\n      },\n      [codes.lowercaseT]: {\n        tokenize: tokenizeTodo,\n      },\n    }\n  };\n\n  function tokenizeTodo(effects, ok, nok) {\n    return startT;\n\n    function startT(code) {\n      effects.enter('todo');\n      effects.enter('data');\n      effects.consume(code);\n      return middleO;\n    }\n    function middleO(code) {\n      if (![codes.uppercaseO, codes.lowercaseO].includes(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return middleDorDash;\n    }\n    function middleDorDash(code) {\n      if (code == codes.dash) {\n        effects.consume(code);\n        return middleD;\n      }\n      return middleD(code);\n    }\n    function middleD(code) {\n      if (![codes.uppercaseD, codes.lowercaseD].includes(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return endO;\n    }\n    function endO(code) {\n      if (![codes.uppercaseO, codes.lowercaseO].includes(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      effects.exit('data');\n      effects.exit('todo');\n      return ok(code);\n    }\n  }\n}\n\n\nfunction todoFromMarkdown() {\n  return {\n    enter: {\n      todo: enterTodo,\n    },\n    exit: {\n      todo: exitTodo,\n    }\n  };\n\n  function enterTodo(token) {\n    this.enter({type: 'todo', children: [], data: {hName: 'span', hProperties: {class: 'todo'}}}, token);\n  }\n  function exitTodo(token) {\n    this.exit(token);\n  }\n}\n\nfunction todoToMarkdown() {\n  return {\n    handlers: {\n      todo,\n    } \n  };\n\n  function todo(node, _, context, safeOptions) {\n    const exit = context.enter('todo');\n    const value = containerPhrasing(node, context, safeOptions);\n    exit();\n    return value;\n  }\n}\n\n\nexport function remarkTodoMarker() {\n  addRemarkExtension(this, todoSyntax(), todoFromMarkdown(), todoToMarkdown());\n}\n","import { visit } from 'unist-util-visit';\nimport { toString } from 'hast-util-to-string';\nimport { camelCase } from 'lodash';\nimport { lowlight } from 'lowlight/lib/all'\nimport { unified } from 'unified';\nimport rehypeParse from 'rehype-parse';\nimport { addClass } from './rehypePlugins';\n\n\nfunction getLanguage(node) {\n  return (node.properties?.className || [])\n    .filter(c => c.startsWith('language-'))\n    .map(c => c.slice(9).toLowerCase())\n    [0] || 'none';\n}\n\nfunction highlightSyntax(code, node) {\n  const language = getLanguage(node);\n  \n  addClass(node, 'hljs');\n  try {\n    return lowlight.highlight(language, code);\n  } catch (error) {\n    if (!/Unknown language/.test(error)) {\n      throw error;\n    }\n  }\n  return {\n    type: 'root',\n    children: [{type: 'text', value: code}]\n  };\n}\n\nfunction parseMeta(metaLine) {\n  const meta = Object.fromEntries(\n    Array.from(metaLine.matchAll(/(?<name>[a-zA-Z0-9\\-]+)(?:=\"(?<value>[^\"]+)\")?/g))\n      .map(m => [camelCase(m.groups.name), m.groups.value || null])\n  );\n  if (meta.highlightManual !== undefined) {\n    meta.highlightManual = meta.highlightManual || '§';\n  }\n  if (meta.lineNumbers !== undefined) {\n    meta.lineNumbers = Number.parseInt(meta.lineNumbers) || 1;\n  }\n  return meta;\n}\n\nfunction parseManualHighlightAreas(code, meta) {\n  const highlightInfos = []\n  if (!meta.highlightManual || meta.highlightManual.length !== 1) {\n      return {code, highlightInfos};\n  }\n\n  const highlightMarkerRe = `\\\\${meta.highlightManual}[^\\\\${meta.highlightManual}\\\\R]*\\\\${meta.highlightManual}`;\n  const highlightedAreaRe = new RegExp(`(${highlightMarkerRe})([^\\\\${meta.highlightManual}]*)(${highlightMarkerRe})`, 'g');\n  const parts = code.split(highlightedAreaRe);\n  let codeNew = '';\n  for (let i = 0; i < parts.length; i += 4) {\n    codeNew += parts[i];\n    if (i + 3 < parts.length) {\n      const highlightInfo = {\n        startMarker: parts[i + 1].slice(1, parts[i + 1].length - 1),\n        startMarkerPos: codeNew.length,\n        endMarker: parts[i + 3].slice(1, parts[i + 3].length - 1),\n        endMarkerPos: 0,\n      };\n      codeNew += parts[i + 2];\n      highlightInfo.endMarkerPos = codeNew.length;\n      highlightInfos.push(highlightInfo);\n    }\n  }\n\n  return {code: codeNew, highlightInfos};\n}\n\n\nfunction splitTreeAtPosition(tree, splitPos) {\n  return {\n    ...tree,\n    children: processChildren(tree.children, 0).flat(),\n  }\n\n  function processChildren(children, currentPos) {\n    const childrenLeft = [];\n    const childrenRight = [];\n\n    for (const c of children) {\n      for (const pc of processNode(c, currentPos)) {\n        if (currentPos < splitPos) {\n          childrenLeft.push(pc);\n        } else {\n          childrenRight.push(pc);\n        }\n        currentPos += toString(pc).length;\n      }\n    }\n    return [childrenLeft, childrenRight];\n  }\n\n  function processNode(node, currentPos) {\n    const nodeLength = toString(node).length;\n    if (currentPos < splitPos && currentPos + nodeLength > splitPos) {\n      if (node.type === 'text') {\n        return [\n          {...node, value: node.value.slice(0, splitPos - currentPos)},\n          {...node, value: node.value.slice(splitPos - currentPos)},\n        ];\n      } else {\n        const [childrenLeft, childrenRight] = processChildren(node.children, currentPos)\n        return [\n          {...node, children: childrenLeft},\n          {...node, children: childrenRight},\n        ];\n      }\n    }\n\n    return [node];\n  }\n}\n\n\nfunction wrapTreeAreas(tree, wrapInfos) {\n  for (const wi of wrapInfos) {\n    // Split highlighted HTML tree at the positions where manual highlight markers will be inserted\n    tree = splitTreeAtPosition(tree, wi.startMarkerPos);\n    tree = splitTreeAtPosition(tree, wi.endMarkerPos);\n  }\n\n  // Insert manual highlighting markers\n  const children = [];\n  for (let ci = 0, wii = 0, currentPos = 0; ci < tree.children.length; currentPos += toString(tree.children[ci]).length, ci++) {\n    const c = tree.children[ci];\n    let wi = wrapInfos[wii];\n\n    if (wi && (currentPos >= wi.startMarkerPos && currentPos + toString(c).length <= wi.endMarkerPos)) {\n      wi.children = (wi.children || []).concat([c]);\n\n      if (currentPos + toString(c).length == wi.endMarkerPos) {\n        visit(wi.markerTree, 'element', (node, index, parent) => {\n          if (node.tagName === 'content-placeholder') {\n            parent.children.splice(index, 1, ...wi.children);\n          }\n        });\n        children.push(...wi.markerTree.children);\n        wii += 1;\n      }\n    } else if (wi && (currentPos === wi.startMarkerPos && currentPos === wi.endMarkerPos)) {\n      visit(wi.markerTree, 'element', (node, index, parent) => {\n        if (node.tagName === 'content-placeholder') {\n          parent.children.splice(index, 1);\n        }\n      });\n      children.push(...wi.markerTree.children);\n      children.push(c);\n      wii += 1;\n    } else {\n      children.push(c);\n    }\n  }\n\n  tree.children = children;\n  return tree;\n}\n\n\nfunction applyManualHighlighting(tree, highlightInfos) {\n  for (const hi of highlightInfos) {\n    // Parse marker as HTML\n    hi.markerTree = unified()\n      .use(rehypeParse, {fragment: true})\n      .parse((hi.startMarker || '<mark>') + '<content-placeholder />' + (hi.endMarker || '</mark>'))\n  }\n\n  return wrapTreeAreas(tree, highlightInfos);\n}\n\n\nfunction splitIntoLines(tree) {\n  const lines = [];\n  let currentPos = 0;\n  for (const line of toString(tree).split('\\n')) {\n    lines.push({\n      startMarkerPos: currentPos,\n      endMarkerPos: currentPos + line.length,\n      markerTree: {\n        type: 'root',\n        children: [\n          {\n            type: 'element',\n            tagName: 'span',\n            properties: {\n              className: ['code-block-line'],\n              dataLineNumber: lines.length + 1\n            },\n            children: [{type: 'element', tagName: 'content-placeholder', children: []}],\n          }\n        ]\n      }\n    });\n    currentPos += line.length + 1;\n  }\n  \n  return wrapTreeAreas(tree, lines);\n}\n\n\nexport function rehypeHighlightCode() {\n  return tree => visit(tree, 'element', (node, index, parent) => {\n    if (node.tagName === 'code' && parent.tagName === 'pre') {\n      addClass(parent, 'code-block');\n\n      const meta = parseMeta(node.data?.meta || '');\n\n      // Manual highlighting\n      const {code, highlightInfos} = parseManualHighlightAreas(toString(node), meta);\n\n      // Syntax highlighting\n      let tree = highlightSyntax(code, node);\n\n      // Add manual highighting\n      if (highlightInfos.length > 0) {\n        tree = applyManualHighlighting(tree, highlightInfos);\n      }\n\n      // Add line infos\n      tree = splitIntoLines(tree);\n\n      node.children = tree.children;\n    } else if (node.tagName === 'code') {\n      addClass(node, 'code-inline');\n    }\n  }); \n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport { addRemarkExtension, assert } from './helpers'\n\n\n/** @type {Construct} */\nconst labelEnd = {\n  name: 'labelEndCustom',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n\n/** @type {Construct} */\nconst resourceConstruct = {tokenize: tokenizeResource}\n/** @type {Construct} */\nconst fullReferenceConstruct = {tokenize: tokenizeFullReference}\n/** @type {Construct} */\nconst collapsedReferenceConstruct = {tokenize: tokenizeCollapsedReference}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (\n      token.type === types.labelImage ||\n      token.type === types.labelLink ||\n      token.type === types.labelEnd ||\n      token.type === 'inlineFootnoteStart' ||\n      token.type === 'inlineFootnoteEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, (token.type === types.labelImage || token.type === 'inlineFootnoteStart') ? 4 : 2)\n      token.type = types.data\n      index++\n    }\n  }\n\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number|undefined} */\n  let open\n  /** @type {number|undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === types.link ||\n        (token.type === types.labelLink && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === types.labelImage || token.type === types.labelLink || token.type === 'inlineFootnoteStart') &&\n        !token._labelEnd_balanced\n      ) {\n        open = index\n\n        if (token.type !== types.labelLink) {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === types.labelEnd || token.type === 'inlineFootnoteEnd') {\n      close = index\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found')\n  assert(close !== undefined, '`close` is supposed to be found')\n\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n\n  splice(events, open, events.length, media)\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === types.labelImage ||\n        self.events[index][1].type === types.labelLink ||\n        self.events[index][1].type === 'inlineFootnoteStart') &&\n      !self.events[index][1]._labelEnd_balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // It’s a balanced bracket, but contains a link.\n    if (labelStart._inactive) return balanced(code)\n\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\n      )\n    )\n    effects.enter(types.labelEnd)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelEnd)\n    return afterLabelEnd\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterLabelEnd(code) {\n    // Resource (`[asd](fgh)`)?\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? ok(code) : balanced(code)\n  }\n\n  /**\n   * Done, it’s nothing.\n   *\n   * There was an okay opening, but we didn’t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function balanced(code) {\n    labelStart._labelEnd_balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n\n  /**\n   * Before a resource, at `(`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren')\n    effects.enter(types.resource)\n    effects.enter(types.resourceMarker)\n    effects.consume(code)\n    effects.exit(types.resourceMarker)\n    return factoryWhitespace(effects, open)\n  }\n\n  /**\n   * At the start of a resource, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === codes.rightParenthesis) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code)\n  }\n\n  /**\n   * In a resource, after a destination, before optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n\n  /**\n   * In a resource, after a destination, after whitespace.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function between(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code)\n    }\n\n    return end(code)\n  }\n\n  /**\n   * In a resource, at the `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker)\n      effects.consume(code)\n      effects.exit(types.resourceMarker)\n      effects.exit(types.resource)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n\n  /**\n   * In a reference (collapsed), at the `[`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    effects.enter(types.reference)\n    effects.enter(types.referenceMarker)\n    effects.consume(code)\n    effects.exit(types.referenceMarker)\n    return open\n  }\n\n  /**\n   * In a reference (collapsed), at the `]`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function open(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker)\n      effects.consume(code)\n      effects.exit(types.referenceMarker)\n      effects.exit(types.reference)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n\n\nexport const labelEndSyntax = {\n  text: {\n    [codes.rightSquareBracket]: labelEnd,\n  }\n};\n\n\n","import { addRemarkExtension } from \"./helpers\";\nimport { labelEndSyntax } from \"./label-end\";\n\n\nexport function modifiedCommonmarkFeatures() {\n  // Disable indented code blocks to not detect indented markdown as code blocks.\n  addRemarkExtension(this, {disable: {null: ['codeIndented']}});\n\n  // Override default labelEnd handler to support parsing nested labels in image captions and footnotes.\n  addRemarkExtension(this, {disable: {null: ['labelEnd']}});\n  addRemarkExtension(this, labelEndSyntax);\n}","\nimport { unified } from 'unified';\nimport remarkParse from 'remark-parse';\nimport remarkRehype from 'remark-rehype';\nimport rehypeStringify from 'rehype-stringify';\nimport rehypeRaw from 'rehype-raw';\nimport remarkStringify from 'remark-stringify';\nimport rehypeSanitize, { defaultSchema } from 'rehype-sanitize';\nimport { merge } from 'lodash';\nimport 'highlight.js/styles/default.css';\n\nimport { remarkFootnotes, remarkToRehypeHandlersFootnotes, rehypeFootnoteSeparator, rehypeFootnoteSeparatorPreview } from './mdext/footnotes.js';\nimport { remarkStrikethrough, remarkTaskListItem } from './mdext/gfm.js';\nimport { rehypeConvertAttrsToStyle, rehypeLinkTargetBlank, rehypeRewriteImageSources, rehypeRewriteFileLinks, rehypeTemplates, rehypeRawFixSelfClosingTags } from './mdext/rehypePlugins.js';\nimport { remarkAttrs, remarkToRehypeAttrs } from './mdext/attrs.js';\nimport { remarkFigure, remarkToRehypeHandlersFigure } from './mdext/image.js';\nimport { remarkTables, remarkTableCaptions, remarkToRehypeHandlersTableCaptions, rehypeTableCaptions } from './mdext/tables.js';\nimport { rehypeReferenceLink, rehypeReferenceLinkPreview } from './mdext/reference.js';\nimport { annotatedTextParse } from './editor/annotatedtext.js';\nimport { remarkTemplateVariables } from './mdext/templates.js';\nimport { remarkTodoMarker } from './mdext/todo.js';\nimport { rehypeHighlightCode } from './mdext/codeHighlight.js';\nimport { modifiedCommonmarkFeatures } from './mdext/modified-commonmark.js';\n\n\nconst rehypeSanitizeSchema = merge({}, defaultSchema, {\n  allowComments: true,\n  clobberPrefix: null,\n  tagNames: ['footnote', 'template', 'ref', 'pagebreak', 'markdown', 'u'].concat(defaultSchema.tagNames),\n  attributes: {\n    '*': ['className', 'style', 'data*', 'v-if', 'v-for', 'v-bind', 'v-on'].concat(defaultSchema.attributes['*']),\n    'a': ['download'].concat(defaultSchema.attributes['a']),\n    'ref': ['to', ':to'],\n    'markdown': ['text', ':text'],\n  }\n});\n\n\nexport function markdownParser() {\n  return unified()\n    .use(modifiedCommonmarkFeatures)\n    .use(remarkFootnotes)\n    .use(remarkTables)\n    .use(remarkTableCaptions)\n    .use(remarkStrikethrough)\n    .use(remarkTaskListItem)\n    .use(remarkTemplateVariables)\n    .use(remarkAttrs)\n    .use(remarkFigure)\n    .use(remarkTodoMarker);\n}\n\n\nexport function formatMarkdown(text) {\n  const md = markdownParser()\n    .use(remarkParse)\n    .use(remarkStringify, {\n      fence: '`',\n      fences: true,\n      bullet: '*',\n      strong: '*',\n      emphasis: '_',\n    });\n  return md.processSync(text).value;\n}\n\nexport function renderMarkdownToHtml(text, {preview = false, rewriteFileSource = null, rewriteReferenceLink = null} = {}) {\n  const md = markdownParser()\n      .use(remarkParse)\n      .use(remarkRehype, { \n        allowDangerousHtml: true, \n        footnoteLabelTagName: 'h4',\n        handlers: {\n          ...(preview ? {} : remarkToRehypeHandlersFootnotes),\n          ...remarkToRehypeHandlersFigure,\n          ...remarkToRehypeHandlersTableCaptions,\n          ...remarkToRehypeAttrs,\n        }\n      })\n      .use(rehypeTableCaptions)\n      .use(rehypeHighlightCode)\n      .use(rehypeRawFixSelfClosingTags)\n      .use(rehypeRaw)\n      .use(rehypeConvertAttrsToStyle)\n      .use(rehypeTemplates)\n      .use(preview ? rehypeFootnoteSeparatorPreview : rehypeFootnoteSeparator)\n      .use(preview ? rehypeReferenceLinkPreview : rehypeReferenceLink, {rewriteReferenceLink})\n      .use(rehypeRewriteImageSources, {rewriteImageSource: rewriteFileSource})\n      .use(rehypeRewriteFileLinks, {rewriteFileUrl: rewriteFileSource})\n      .use(rehypeLinkTargetBlank)\n      .use(rehypeSanitize, rehypeSanitizeSchema)\n      .use(rehypeStringify);\n\n    // const mdAst = md.parse(text);\n    // console.log('MarkdownAST', mdAst);\n    // const rehypeAst = md.runSync(mdAst);\n    // console.log('RehypeAST', rehypeAst);\n    // const mdHtml = md.stringify(rehypeAst);\n    // console.log('HTML', mdHtml);\n    const mdHtml = md.processSync(text).value;\n    return mdHtml;\n}\n\n\nexport function markdownToAnnotatedText(text) {\n  const md = markdownParser()\n    .use(annotatedTextParse);\n  const at = md.parse(text);\n  // console.log('AnnotatedText', at);\n  return at;\n}\n","import {parse} from 'micromark/lib/parse.js';\nimport {preprocess} from 'micromark/lib/preprocess.js';\nimport {postprocess} from 'micromark/lib/postprocess.js';\nimport {assert} from '../mdext/helpers.js';\n\n\nexport function parseMicromarkEvents(text, config) {\n  return postprocess(parse(config).document().write(preprocess()(text, undefined, true)));\n}\n\nexport function micromarkEventsToTree(text, events) {\n  // console.log('micromark events', events);\n\n  // build enter/exit tree of nested elements\n  const tree = [];\n  const stack = [];\n  for (const [action, node, context] of events) {\n    if (action === 'enter') {\n      const treeNode = {\n        enter: node,\n        exit: null,  \n        children: [],\n\n        type: node.type,\n        text: null,\n      };\n      if (stack.length > 0) {\n        stack[stack.length - 1].children.push(treeNode);\n      } else {\n        tree.push(treeNode);\n      }\n      stack.push(treeNode);\n    } else if (action === 'exit') {\n      const treeNode = stack[stack.length - 1];\n      assert(treeNode.type == node.type);\n\n      treeNode.exit = node;\n      treeNode.text = text.slice(treeNode.enter.start.offset, treeNode.exit.end.offset);\n      stack.splice(stack.length - 1, 1);\n    }\n  }\n  // console.log('micromark tree', tree);\n  return tree;\n}\n"],"sourceRoot":""}