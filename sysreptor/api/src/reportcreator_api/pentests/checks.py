import itertools
from typing import Any, Iterable, Union
from reportcreator_api.pentests import cvss
from reportcreator_api.pentests.customfields.types import FieldDataType
from reportcreator_api.pentests.customfields.utils import iterate_fields
from reportcreator_api.pentests.models import PentestFinding, PentestProject, ProjectType, ReportSection, ReviewStatus
from reportcreator_api.utils.error_messages import ErrorMessage, MessageLevel, MessageLocationInfo, MessageLocationType

from reportcreator_api.utils.utils import find_all_indices


class ReportCheck:
    def location_info(self, obj, path=None):
        if isinstance(obj, PentestProject):
            return MessageLocationInfo(
                type=MessageLocationType.PROJECT,
                id=obj.id,
                name=obj.name,
            ).for_path(path)
        elif isinstance(obj, ReportSection):
            return MessageLocationInfo(
                type=MessageLocationType.SECTION,
                id=obj.section_id,
                name=obj.section_label,
            ).for_path(path)
        elif isinstance(obj, PentestFinding):
            return MessageLocationInfo(
                type=MessageLocationType.FINDING,
                id=obj.finding_id,
                name=obj.data.get('title'),
            ).for_path(path)
        elif isinstance(obj, ProjectType):
            return MessageLocationInfo(
                type=MessageLocationType.DESIGN,
                id=obj.id,
                name=obj.name,
            ).for_path(path)
        else:
            raise ValueError('Unsupported MessageLocationInfo')
    
    def check(self, project: PentestProject) -> Iterable[ErrorMessage]:
        return itertools.chain(
            self.check_project(project),
            *map(self.check_section, project.sections.all()),
            *map(self.check_finding, project.findings.all()),
        )

    def check_project(self, project: PentestProject) -> Iterable[ErrorMessage]:
        return []
    
    def check_section(self, section: ReportSection) -> Iterable[ErrorMessage]:
        return []
    
    def check_finding(self, finding: PentestFinding) -> Iterable[ErrorMessage]:
        return []


class TodoCheck(ReportCheck):
    def check_todos_in_field(self, data: dict, definition: dict, location: MessageLocationInfo) -> Iterable[ErrorMessage]:
        for p, v, d in iterate_fields(value=data, definition=definition):
            if isinstance(v, str):
                snippets = []
                for idx in itertools.chain(*map(lambda s: find_all_indices(v, s), ['TODO', 'todo', 'ToDo', 'TO-DO', 'To-Do', 'To-do', 'to-do'])):
                    snippet = v[idx:].splitlines()[0]
                    if len(snippet) > 100:
                        snippet = snippet[:100] + '...'
                    snippets.append(snippet)
                if snippets:
                    yield ErrorMessage(
                        level=MessageLevel.WARNING, 
                        location=location.for_path(p), 
                        message='Unresolved TODO',
                        details='\n'.join(snippets))

    def check_section(self, section) -> Iterable[ErrorMessage]:
        return self.check_todos_in_field(section.data, section.field_definition, self.location_info(section))
    
    def check_finding(self, finding) -> Iterable[ErrorMessage]:
        return self.check_todos_in_field(finding.data, finding.field_definition, self.location_info(finding))


class EmptyFieldsCheck(ReportCheck):
    def check_field(self, data: dict, definition: dict, location: MessageLocationInfo) -> Iterable[ErrorMessage]:
        for p, v, d in iterate_fields(value=data, definition=definition):
            if getattr(d, 'required', False) and (v is None or v == '' or v == []):
                yield ErrorMessage(
                    level=MessageLevel.WARNING,
                    location=location.for_path(p),
                    message='Empty field',
                )

    def check_section(self, section) -> Iterable[ErrorMessage]:
        return self.check_field(section.data, section.field_definition, self.location_info(section))
    
    def check_finding(self, finding) -> Iterable[ErrorMessage]:
        return self.check_field(finding.data, finding.field_definition, self.location_info(finding))


class StatusCheck(ReportCheck):
    def check_status(self, obj: Union[ReportSection, PentestFinding]):
        if obj.status != ReviewStatus.FINISHED:
            yield ErrorMessage(
                level=MessageLevel.WARNING,
                location=self.location_info(obj=obj),
                message=f'Status is not "{ReviewStatus.FINISHED}"',
                details=f'Status is "{obj.status}", not status "{ReviewStatus.FINISHED}"',
            )

    def check(self, project: PentestProject) -> Iterable[ErrorMessage]:
        # If all findings and sections have status "in-progress", deactivate this check.
        # We assume that the users of the project do not use the review feature and statuses.
        # This removed unnecessary (and ignored) warnings if no statuses are used.
        if any(map(lambda s: s.status != ReviewStatus.IN_PROGRESS, project.sections.all())) or \
            any(map(lambda f: f.status != ReviewStatus.IN_PROGRESS, project.findings.all())):
            return super().check(project)
        else:
            return []

    def check_section(self, section: ReportSection) -> Iterable[ErrorMessage]:
        return self.check_status(section)
    
    def check_finding(self, finding: PentestFinding) -> Iterable[ErrorMessage]:
        return self.check_status(finding)


class CvssFieldCheck(ReportCheck):
    def check_finding(self, finding) -> Iterable[ErrorMessage]:
        for p, v, d in iterate_fields(value=finding.data, definition=finding.field_definition):
            if d.type == FieldDataType.CVSS and not cvss.is_cvss(v) and v != 'n/a' and v not in [None, '', 'n/a']:
                yield ErrorMessage(
                    level=MessageLevel.WARNING,
                    location=self.location_info(obj=finding, path=p),
                    message='Invalid CVSS vector',
                    details=f'"{v}" is not a valid CVSS vector. Enter "n/a" when no CVSS vector is applicable.'
                )


def run_checks(project) -> Iterable[ErrorMessage]:
    def perform_check(checker):
        try:
            return checker.check(project)
        except Exception as ex:
            return [ErrorMessage(
                level=MessageLevel.ERROR,
                location=MessageLocationInfo(type=MessageLocationType.OTHER),
                message='Error while checking data',
                details=str(ex),
            )]
    return list(itertools.chain(*map(perform_check, [TodoCheck(), EmptyFieldsCheck(), CvssFieldCheck(), StatusCheck()])))
