import enum
from django.conf import settings
from django.db import DatabaseError, models, transaction, IntegrityError
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from reportcreator_api.utils.models import BaseModel
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.relations import GenericOneToOneForeignKey, GenericOneToOneRelation


class LockStatus(enum.Enum):
    CREATED = 'created'
    REFRESHED = 'refreshed'
    FAILED = 'failed'


class LockInfo(BaseModel):
    # Generic foreign key to arbitrary/multiple models
    content_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)
    object_id = models.UUIDField()
    locked_object = GenericOneToOneForeignKey(ct_field='content_type', fk_field='object_id')

    last_ping = models.DateTimeField(default=timezone.now)
    user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=False)

    class Meta:
        unique_together = [('content_type', 'object_id')]

    @property
    def expires(self):
        return (self.last_ping or timezone.now()) + settings.MAX_LOCK_TIME

    def refresh_lock(self):
        try:
            self.last_ping = timezone.now()
            self.save(force_update=True)
            return LockStatus.REFRESHED
        except (self.DoesNotExist, DatabaseError):
            return LockStatus.FAILED


class LockableMixin(models.Model):
    lock_info_data = GenericOneToOneRelation(to=LockInfo)

    class Meta:
        abstract = True

    @property
    def lock_info(self):
        if not self.is_locked:
            return None
        return self.lock_info_data

    @property
    def is_locked(self):
        return self.lock_info_data is not None and timezone.now() <= self.lock_info_data.expires

    def _cleanup_old_lock(self):
        if self.lock_info_data:
            self.lock_info_data.delete()
            self.lock_info_data = None

    def lock(self, user, refresh_lock=True):
        if self.is_locked and self.lock_info.user != user:
            # Already locked by another user
            return LockStatus.FAILED
        elif self.is_locked and self.lock_info.user == user:
            # Refresh lock such that it does not expire
            if refresh_lock:
                return self.lock_info.refresh_lock()
            else:
                return LockStatus.REFRESHED
        elif not self.is_locked:
            with transaction.atomic():
                self._cleanup_old_lock()
                try:
                    self.lock_info_data = LockInfo.objects.create(locked_object=self, user=user)
                    return LockStatus.CREATED
                except IntegrityError:
                    self.lock_info_data = LockInfo.objects.get(content_type=ContentType.objects.get_for_model(self), object_id=self.id)
                    if self.lock_info_data.user == user:
                        return LockStatus.REFRESHED
                    else:
                        return LockStatus.FAILED
        return LockStatus.FAILED

    def unlock(self, user):
        if not self.is_locked:
            self._cleanup_old_lock()
            return True
        elif self.is_locked and self.lock_info.user == user:
            self._cleanup_old_lock()
            return True
        else:
            return False


class SourceEnum(models.TextChoices):
    CREATED = 'created', 'Created'
    IMPORTED = 'imported', 'Imported'
    IMPORTED_DEPENDENCY = 'imported_dependency', 'Imported Dependency'
    CUSTOMIZED = 'customized', 'Customized'
    SNAPSHOT = 'snapshot', 'Snapshot'


class ImportableMixin(models.Model):
    source = models.CharField(max_length=50, choices=SourceEnum.choices, default=SourceEnum.CREATED, db_index=True, editable=False)

    class Meta:
        abstract = True


class ReviewStatus(models.TextChoices):
    IN_PROGRESS = 'in-progress', _('In progress')
    READY_FOR_REVIEW = 'ready-for-review', _('Ready for review')
    NEEDS_IMPROVEMENT = 'needs-improvement', _('Needs improvement')
    FINISHED = 'finished', _('Finished')


class Language(models.TextChoices):
    ENGLISH = 'en-US', True, 'English'
    GERMAN = 'de-DE', True, 'German'
    SPANISH = 'es-ES', True, 'Spanish'
    FRENCH = 'fr-FR', True, 'French'
    PORTUGUESE = 'pt-PT', True, 'Portuguese'
    ITALIAN = 'it-IT', True, 'Italian'
    DUTCH = 'nl-NL', True, 'Dutch'
    DANISH = 'da-DK', True, 'Danish'
    POLISH = 'pl-PL', True, 'Polish'
    UKRAINIAN = 'uk-UA', True, 'Ukrainian'
    # RUSSIAN = 'ru-RU', True, 'Russian'
    ROMANIAN = 'ro-RO', True, 'Romanian'
    SLOVAK = 'sk-SK', True, 'Slovak'
    SLOVENIAN = 'sl-SI', True, 'Slovenian'
    GREEK = 'el-GR', True, 'Greek'
    SWEDISH = 'sv-SE', True, 'Swedish'

    # Languages without LanguageTool support
    ALBANIAN = 'sq-AL', False, 'Albanian'
    BULGARIAN = 'bg-BG', False, 'Bulgarian'
    CROATIAN = 'hr-HR', False, 'Croatian'
    ESTONIAN = 'et-EE', False, 'Estonian'
    FINNISH = 'fi-FI', False, 'Finnish'
    HUNGARIAN = 'hu-HU', False, 'Hungarian'
    LATVIAN = 'lv-LV', False, 'Latvian'
    LITHUANIAN = 'lt-LT', False, 'Lithuanian'
    MALTESE = 'mt-MT', False, 'Maltese'
    NORWEGIAN = 'nb-NO', False, 'Norwegian'
    SERBIAN = 'sr-SP', False, 'Serbian'
    TURKISH = 'tr-TR', False, 'Turkish'

    def __new__(cls, value, spellcheck):
        obj = str.__new__(cls, value)
        obj._value_ = value
        obj.spellcheck = spellcheck
        return obj


def get_default_language():
    if settings.PREFERRED_LANGUAGES:
        return Language(settings.PREFERRED_LANGUAGES[0])
    return Language.ENGLISH


class LanguageMixin(models.Model):
    language = models.CharField(choices=Language.choices, default=get_default_language, max_length=5, db_index=True)
    
    class Meta:
        abstract = True

