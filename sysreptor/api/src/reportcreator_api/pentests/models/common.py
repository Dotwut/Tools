import enum
from django.conf import settings
from django.db import models, transaction, IntegrityError
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from reportcreator_api.utils.models import BaseModel
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.relations import GenericOneToOneForeignKey, GenericOneToOneRelation


class LockStatus(enum.Enum):
    CREATED = 'created'
    REFRESHED = 'refreshed'
    FAILED = 'failed'


class LockInfo(BaseModel):
    # Generic foreign key to arbitrary/multiple models
    content_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)
    object_id = models.UUIDField()
    locked_object = GenericOneToOneForeignKey(ct_field='content_type', fk_field='object_id')

    last_ping = models.DateTimeField(default=timezone.now)
    user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=False)

    class Meta:
        unique_together = [('content_type', 'object_id')]

    @property
    def expires(self):
        return (self.last_ping or timezone.now()) + settings.MAX_LOCK_TIME

    def refresh_lock(self):
        try:
            self.last_ping = timezone.now()
            self.save(force_update=True)
            return LockStatus.REFRESHED
        except self.DoesNotExist:
            return LockStatus.FAILED


class LockableMixin(models.Model):
    lock_info_data = GenericOneToOneRelation(to=LockInfo)

    class Meta:
        abstract = True

    @property
    def lock_info(self):
        if not self.is_locked:
            return None
        return self.lock_info_data

    @property
    def is_locked(self):
        return self.lock_info_data is not None and timezone.now() <= self.lock_info_data.expires

    def _cleanup_old_lock(self):
        if self.lock_info_data:
            self.lock_info_data.delete()
            self.lock_info_data = None

    def lock(self, user, refresh_lock=True):
        if self.is_locked and self.lock_info.user != user:
            # Already locked by another user
            return LockStatus.FAILED
        elif self.is_locked and self.lock_info.user == user:
            # Refresh lock such that it does not expire
            if refresh_lock:
                return self.lock_info.refresh_lock()
            else:
                return LockStatus.REFRESHED
        elif not self.is_locked:
            with transaction.atomic():
                self._cleanup_old_lock()
                try:
                    self.lock_info_data = LockInfo.objects.create(locked_object=self, user=user)
                    return LockStatus.CREATED
                except IntegrityError:
                    self.lock_info_data = LockInfo.objects.get(content_type=ContentType.objects.get_for_model(self), object_id=self.id)
                    if self.lock_info_data.user == user:
                        return LockStatus.REFRESHED
                    else:
                        return LockStatus.FAILED
        return LockStatus.FAILED

    def unlock(self, user):
        if not self.is_locked:
            self._cleanup_old_lock()
            return True
        elif self.is_locked and self.lock_info.user == user:
            self._cleanup_old_lock()
            return True
        else:
            return False


class SourceEnum(models.TextChoices):
    CREATED = 'created', 'Created'
    IMPORTED = 'imported', 'Imported'
    IMPORTED_DEPENDENCY = 'imported_dependency', 'Imported Dependency'
    CUSTOMIZED = 'customized', 'Customized'
    SNAPSHOT = 'snapshot', 'Snapshot'


class ImportableMixin(models.Model):
    source = models.CharField(max_length=50, choices=SourceEnum.choices, default=SourceEnum.CREATED, db_index=True, editable=False)

    class Meta:
        abstract = True


class ReviewStatus(models.TextChoices):
    IN_PROGRESS = 'in-progress', _('In progress')
    READY_FOR_REVIEW = 'ready-for-review', _('Ready for review')
    NEEDS_IMPROVEMENT = 'needs-improvement', _('Needs improvement')
    FINISHED = 'finished', _('Finished')


class Language(models.TextChoices):
    ENGLISH = 'en-US', 'English'
    GERMAN = 'de-DE', 'German'


class LanguageMixin(models.Model):
    language = models.CharField(choices=Language.choices, default=Language.GERMAN, max_length=5, db_index=True)
    
    class Meta:
        abstract = True

